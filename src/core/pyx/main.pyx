'''
Author: Victor Ruiz Gomez
Description: This is an autogenerated source file made by the setup.py script.
It contains all Cython definitions (methods & classes) of this library extension in order to interact with lib3d_mec_ginac
Version : 1.0.0
'''


######## src/core/pyx/imports.pyx ########



######## Cython internal library imports ########

cimport cython
from cython.operator import dereference as c_deref




######## C/C++ standard library imports ########

from libcpp.string cimport string as c_string
from libcpp.vector cimport vector as c_vector

# Math
from libc.math cimport modf as c_modf

# Output streams
from src.core.pxd.cpp cimport ostream as c_ostream
from src.core.pxd.cpp cimport stringstream as c_sstream



######## C++ lib3d-mec-ginac imports ########

# Classes
from src.core.pxd.csymbol_numeric cimport symbol_numeric as c_symbol_numeric
from src.core.pxd.csystem         cimport System         as c_System
from src.core.pxd.cbase           cimport Base           as c_Base
from src.core.pxd.cmatrix         cimport Matrix         as c_Matrix
from src.core.pxd.cvector3D       cimport Vector3D       as c_Vector3D
from src.core.pxd.ctensor3D       cimport Tensor3D       as c_Tensor3D
from src.core.pxd.cpoint          cimport Point          as c_Point
from src.core.pxd.cframe          cimport Frame          as c_Frame
from src.core.pxd.csolid          cimport Solid          as c_Solid
from src.core.pxd.cwrench3D       cimport Wrench3D       as c_Wrench3D
from src.core.pxd.cdrawing3D      cimport Drawing3D      as c_Drawing3D

# Global functions
from src.core.pxd.cglobals        cimport atomization          as c_atomization
from src.core.pxd.cglobals        cimport gravity              as c_gravity
from src.core.pxd.cglobals        cimport unatomize            as c_unatomize
from src.core.pxd.cglobals        cimport subs                 as c_subs
from src.core.pxd.cglobals        cimport matrix_list_optimize as c_matrix_list_optimize




######## C++ GiNaC imports ########

from src.core.pxd.ginac.cnumeric cimport numeric as c_numeric
from src.core.pxd.ginac.cexpr    cimport ex      as c_ex
from src.core.pxd.ginac.cbasic   cimport basic   as c_basic
from src.core.pxd.ginac.csymbol  cimport symbol  as c_symbol
from src.core.pxd.ginac.cmatrix  cimport matrix  as c_ginac_matrix
from src.core.pxd.ginac.clst     cimport lst     as c_lst

# Utility functions
from src.core.pxd.ginac.cexpr cimport is_a as c_is_a
from src.core.pxd.ginac.cexpr cimport ex_to as c_ex_to

# Printing classes & functions
from src.core.pxd.ginac.cprint cimport print_context  as c_ginac_printer
from src.core.pxd.ginac.cprint cimport print_python   as c_ginac_python_printer
from src.core.pxd.ginac.cprint cimport print_latex    as c_ginac_latex_printer
from src.core.pxd.ginac.cprint cimport set_print_func as c_ginac_set_print_func

# Symbolic math functions
from src.core.pxd.ginac.cmath cimport pow as c_sym_pow
from src.core.pxd.ginac.cmath cimport sin as c_sym_sin, cos as c_sym_cos, tan as c_sym_tan




######## Python imports ########

# Collections
from collections import OrderedDict
from collections.abc import Iterable, Mapping, Sized

# Utilities
from functools import partial, partialmethod, wraps
from itertools import chain, starmap, repeat, product
from operator import attrgetter
from warnings import warn
from abc import ABC
from types import MethodType
from re import match, finditer
from inspect import Signature, Parameter
import json

# Math
import math
from math import floor


# Third party libraries
from asciitree import LeftAligned
from tabulate import tabulate
import numpy as np



######## src/core/pyx/globals.pyx ########




######## Change gravity direction ########


def set_gravity_direction(state):
    '''set_gravity(state: int | str)
    Toggle gravity down or up.

    :param state:
        * If its True, 1 or "up", gravity is turned up.
        * If its False, 0 or "down", gravity is turned down.

    '''
    global c_gravity

    if not isinstance(state, (int, str)):
        raise TypeError('Input argument must be str or int')

    if isinstance(state, str):
        if state not in ('up', 'down'):
            raise TypeError('Possible values for gravity state are "up" and "down"')
        state = state == 'up'
    else:
        state = bool(state)

    c_gravity = state



def set_gravity_up():
    '''
    Toggle gravity up.
    '''
    set_gravity_direction(1)


def set_gravity_down():
    '''
    Toggle gravity down.
    '''
    set_gravity_direction(0)




def get_gravity_direction():
    '''get_gravity_direction() -> int
    Get the gravity direction. Returns 1 if it is turned up, and 0 if its down.

    :rtype: int

    '''
    return int(c_gravity)



# Default gravity direction is "down"
set_gravity_down()





######## Change atomization ########


def set_atomization_state(state):
    '''set_atomization_state(state: int | str)
    Toggle atomization on or off

    :param state:
        * If its True, 1 or "on", atomization is enabled
        * If its False, 0 or "off", atomization is disabled

    '''
    global c_atomization

    if not isinstance(state, (int, str)):
        raise TypeError('Input argument must be str or int')

    if isinstance(state, str):
        if state not in ('on', 'off'):
            raise TypeError('Possible values for atomization state are "on" and "off"')
        state = state == 'on'
    else:
        state = bool(state)

    c_atomization = state



def enable_atomization():
    '''
    Toggle atomization on
    '''
    set_atomization_state(1)


def disable_atomization():
    '''
    Toggle atomization off
    '''
    set_atomization_state(0)



def get_atomization_state():
    '''
    Returns 1 if atomization is enabled. 0 othwerwise.

    :rtype: int

    '''
    return int(c_atomization)


# Default atomizatio state is "enabled"
enable_atomization()




######## Unatomize ########


def unatomize(x):
    '''unatomize(x: Expr | Matrix | Wrench3D) -> Expr | Matrix | Wrench3D
    Unatomize the given expression, matrix or wrench
    '''

    if not isinstance(x, (Expr, Matrix, Wrench3D)):
        raise TypeError('Input argument must be an expression, matrix or wrench')

    if isinstance(x, Expr):
        # unatomize expression
        return _expr_from_c(c_unatomize((<Expr>x)._c_handler))

    if isinstance(x, Vector3D):
        # unatomize vector
        return _vector_from_c_value(c_unatomize(c_deref(<c_Vector3D*>(<Vector3D>x)._get_c_handler())))

    if isinstance(x, Tensor3D):
        # unatomize tensor
        return _tensor_from_c_value(c_unatomize(c_deref(<c_Tensor3D*>(<Tensor3D>x)._get_c_handler())))

    if isinstance(x, Wrench3D):
        # unatomize wrench
        return _wrench_from_c_value(c_unatomize(c_deref((<Wrench3D>x)._c_handler)))

    # unatomize matrix
    return _matrix_from_c_value(c_unatomize(c_deref((<Matrix>x)._get_c_handler())))




######## Recursive substitution ########


def subs(matrix, symbols, repl):
    '''subs(matrix: Matrix, symbols: Matrix | List[SymbolNumeric] | SymbolNumeric, repl: numeric) -> Matrix
    Performs a substitution of a vector of symbols or a symbol with a numeric value in all
    of the elements of the given matrix.

    * Replace a symbol with a numeric value:

        :Example:

        >>> a, b = new_param('a'), new_param('b')
        >>> m = Matrix([[a ** 2, a ** b], [b ** a, b ** 2]])
        >>> m
        ╭            ╮
        │ a**2  a**b │
        │ b**a  b**2 │
        ╰            ╯
        >>> subs(m, a, 0)
        ╭             ╮
        │ 0  (0.0)**b │
        │ 1      b**2 │
        ╰             ╯
        >>> subs(m, a, 1)
        ╭         ╮
        │ 1     1 │
        │ b  b**2 │
        ╰         ╯
        >>> subs(m, b, 1)
        ╭         ╮
        │ a**2  a │
        │    1  1 │
        ╰         ╯

    * Replace multiple symbols with a numeric value:

        :Example:

        >>> m = Matrix([[a ** 2, a - b], [b - a, b ** 2]])
        >>> m
        ╭            ╮
        │ a**2   a-b │
        │ -a+b  b**2 │
        ╰            ╯
        >>> subs(m, [a, b], 2)
        ╭      ╮
        │ 4  0 │
        │ 0  4 │
        ╰      ╯
        >>> q = Matrix([a, b])
        >>> subs(m, q, 1)
        ╭      ╮
        │ 1  0 │
        │ 0  1 │
        ╰      ╯


    :param symbols: Must be a matrix or a list of symbols to be replaced. It can also
        be a single symbol.
        If its a matrix, it must have a single row or column.
    :type symbols: Matrix, List[SymbolNumeric], SymbolNumeric

    :param repl: The numeric value which will be used to replace the symbols with

    :type repl: numeric

    :rtype: Matrix

    '''
    if not isinstance(matrix, Matrix):
        raise TypeError('First argument must be a matrix object')
    return matrix.subs(symbols, repl)





######## Math functions ########


cpdef sin(x):
    '''sin(x: Expr | SymbolNumeric | numeric) -> Expr | float
    Compute the sine of the given numeric or symbolic angle expressed in radians.
    If the input argument is numeric, the sine is evaluated numerically. Otherwise,
    a symbolic expression equal to the sine of the given input is returned.

        :Example:

        >>> from math import radians
        >>> sin(radians(45))
        0.7071067811865475
        >>> a, b = new_param('a'), new_param('b')
        >>> sin(a ** 2) / sin(b ** 2)
        sin(a**2)*sin(b**2)**(-1)


    :param x: Expr | SymbolNumeric | numeric
    :rtype: Expr | float

    '''
    if isinstance(x, (Expr, SymbolNumeric)):
        if isinstance(x, SymbolNumeric):
            x = Expr(x)
        return _expr_from_c(c_sym_sin((<Expr>x)._c_handler))
    return math.sin(_parse_numeric_value(x))



cpdef cos(x):
    '''cos(x: Expr | SymbolNumeric | numeric) -> Expr | float
    Compute the cosine of the given numeric or symbolic angle expressed in radians.
    If the input argument is numeric, the sine is evaluated numerically. Otherwise,
    a symbolic expression equal to the cosine of the given input is returned.

        :Example:

        >>> from math import radians
        >>> cos(radians(45))
        0.7071067811865475
        >>> a, b = new_param('a'), new_param('b')
        >>> cos(a ** 2) / cos(b ** 2)
        cos(a**2)*cos(b**2)**(-1)


    :param x: Expr | SymbolNumeric | numeric
    :rtype: Expr | float

    '''
    if isinstance(x, (Expr, SymbolNumeric)):
        if isinstance(x, SymbolNumeric):
            x = Expr(x)
        return _expr_from_c(c_sym_cos((<Expr>x)._c_handler))
    return math.cos(_parse_numeric_value(x))



cpdef tan(x):
    '''tan(x: Expr | SymbolNumeric | numeric) -> Expr | float
    Compute the tangent of the given numeric or symbolic angle expressed in radians.
    If the input argument is numeric, the sine is evaluated numerically. Otherwise,
    a symbolic expression equal to the tangent of the given input is returned.


        :Example:

        >>> from math import radians
        >>> tan(radians(75))
        3.7320508075688776
        >>> a, b = new_param('a'), new_param('b')
        >>> tan(a ** 2) / tan(b ** 2)
        tan(a**2)*tan(b**2)**(-1)


    :param x: Expr | SymbolNumeric | numeric
    :rtype: Expr | float

    '''
    if isinstance(x, (Expr, SymbolNumeric)):
        if isinstance(x, SymbolNumeric):
            x = Expr(x)
        return _expr_from_c(c_sym_tan((<Expr>x)._c_handler))
    return math.tan(_parse_numeric_value(x))



######## src/core/pyx/parse.pyx ########



def _parse_text(text):
    '''
    Check that input argument is a string or bytes object. If not, raises
    TypeError. The return value is always the input converted as a bytes object.
    '''
    if not isinstance(text, (str, bytes)):
        raise TypeError
    if isinstance(text, str):
        text = text.encode()
    return text




def _parse_name(name, check_syntax=False):
    '''
    Check that input argument is a valid name for numeric symbols, vectors, matrices, ...

    :param name: The name to be validated
    :param check_syntax: If True, the name syntax will also be validated
        Name should be composed with one ore more alphanumeric chars and underscores. Also, the
        first character cannot be a digit.

    :raises TypeError: If the input argument is not str or bytes object
    :raises ValueError: If the input argument is not a valid name
    :returns: The input argument converted to a bytes object on success
    :rtype: bytes
    '''
    try:
        name = _parse_text(name)
    except TypeError:
        raise TypeError('Name must be a str or bytes object')

    if check_syntax and not name.decode().isidentifier():
        raise ValueError(f'"{name.decode()}" is not a valid name')

    return name




def _parse_symbol_type(kind):
    '''
    Check that input argument is a valid numeric symbol type, that is, it must be
    equal to one the next values:
    'parameter', 'input', 'joint_unknown', 'coordinate', 'velocity', 'acceleration',
    'aux_coordinate', 'aux_velocity', 'aux_acceleration'

    :raises TypeError: If the input argument is not str or bytes object
    :raises ValueError: If the input argument is not a valid symbol type.
    :returns: The input argument string converted to bytes on success
    :rtype: bytes
    '''
    try:
        kind = _parse_text(kind)
    except TypeError:
        raise TypeError('Symbol type must be a str or bytes object')

    if kind not in _symbol_types:
        raise ValueError(f'Invalid "{kind.decode()}" symbol type')
    return kind




def _parse_numeric_value(value):
    '''
    Convert the input argument to a float value.
    It invokes __float__ metamethod of the input argument if it is not a float object.
    If it doesnt have such method defined, it raises TypeError
    '''
    if not isinstance(value, float):
        try:
            value = float(value)
        except:
            raise TypeError(f'Invalid numeric value')
    return value




def _apply_signature(params, defaults, args=[], kwargs={}):
    '''
    This method emulates the binding process of arbitrary positional and keyword arguments to
    a function signature.

    :param params: Must be a list of strings indicating the name of the parameters
        to bind the input arguments
    :param defaults: Its a dictionary where keys are parameter names and values, their default
        values
    :param args: The input positional arguments to bind to the parameters
    :param kwargs: The input keyword arguments to bind to the parameters
    :rtype: A tuple with the bounded arguments to the parameters specified
    :raises TypeError: If the input positional and keyword arguments cannot be binded to the
        given parameters

    :Example:

    >>> a, b = _apply_signature(
    >>>    ['a', 'b'],
    >>>    {'b': 2},
    >>>    args=[1]
    >>> )
    >>> print(a, b)
    1, 2

    >>> x, y = _apply_signature(['x', 'y'], {}, args=[], kwargs={'x':1})
    TypeError: missing a required argument: 'y'
    '''
    assert isinstance(params, Iterable)
    assert isinstance(defaults, dict)

    sig = Signature(
        parameters=[Parameter(param, Parameter.POSITIONAL_OR_KEYWORD, default=defaults.get(param, Parameter.empty)) for param in params]
    )
    bounded_args = sig.bind(*args, **kwargs)
    bounded_args.apply_defaults()
    return bounded_args.args



######## src/core/pyx/views.pyx ########






######## Class View ########

cdef class View:
    def __str__(self):
        return ConsolePrinter().print(self)

    def __repr__(self):
        return self.__str__()



######## Class TableView ########

cdef class TableView(View):
    def __init__(self, data=None, headers=None):
        self.data = data if data is not None else []
        self.headers = headers if headers is not None else ()





######## Subclasses of TableView ########


class SymbolsTableView(TableView):
    def __init__(self, system, kind=None):
        if kind is None:
            data = [(symbol.name, symbol.type, symbol.value) for symbol in system._get_symbols()]
            headers = ['name', 'type', 'value']
        else:
            data = [(symbol.name, symbol.value) for symbol in system._get_symbols()]
            headers = None

        super().__init__(
            headers=headers,
            data=data
        )




class MatricesTableView(TableView):
    def __init__(self, system):
        super().__init__(
            headers=['name', 'size'],
            data=[(m.name, f'{m.num_rows}x{m.num_cols}') for m in system._get_matrices()]
        )



class VectorsTableView(TableView):
    def __init__(self, system):
        super().__init__(
            headers=['name', 'x', 'y', 'z', 'base'],
            data=[(v.name, v.x, v.y, v.z, v.base.name) for v in system._get_vectors()]
        )



class TensorsTableView(TableView):
    def __init__(self, system):
        super().__init__(
            headers=['name', 'base'],
            data=[(t.name, t.base.name) for t in system._get_tensors()]
        )



class BasesTableView(TableView):
    def __init__(self, system):
        super().__init__(
            headers=['name', 'previous', 'rot.tupla', 'rot.angle'],
            data=[(b.name, b.previous if b.has_previous() else None,
                '  '.join(map(str, b.rotation_tupla)), b.rotation_angle) for b in system._get_bases()]
        )



class PointsTableView(TableView):
    def __init__(self, system):
        super().__init__(
            headers=['name', 'position'],
            data=[(p.name, p.position.name if p.has_previous() else None) for p in system._get_points()]
        )



class FramesTableView(TableView):
    def __init__(self, system):
        super().__init__(
            headers=['name', 'point', 'base'],
            data=[(f.name, f.point.name, f.base.name) for f in system._get_frames()]
        )



class SolidsTableView(TableView):
    def __init__(self, system):
        super().__init__(
            headers=['name', 'point', 'base', 'mass', 'CM', 'IT'],
            data=[(s.name, s.point.name, s.base.name, str(s.mass), s.CM.name, s.IT.name) for s in system._get_solids()]
        )



class WrenchesTableView(TableView):
    def __init__(self, system):
        super().__init__(
            headers=['name', 'force', 'moment', 'solid', 'type'],
            data=[(w.name, w.force.name, w.moment.name, w.solid.name, w.type) for w in system._get_wrenches()]
        )


class DrawingsTableView(TableView):
    def __init__(self, system):
        super().__init__(
            headers=['name'],
            data=[(d.name,) for d in system._get_drawings()]
        )



######## src/core/pyx/print.pyx ########



######## Class printer ########

cdef class Printer:
    '''
    Subclasses of Printer can be used to print any kind of object which inherits from
    Object class:

        :Example:

        >> printer = ConsolePrinter()

        # Print a symbol
        >> printer.print(new_param('a', 1))
        a = 1

        # Print a expression
        >> b, c = new_param('b', tex_name='\\beta', 2), new_param('c', tex_name='\\gamma', 3)
        >> printer.print(b + c)
        '\\beta+\\gamma'

        # Print a table of parameters (a view)
        >> printer.print(get_params())
        name   value
        a        1.0
        b        2.0
        c        3.0
    '''

    def print(self, x):
        '''
        Prints the given object or view using this printer.

        :param obj: The object to be printed
        :rtype: str

        :raises NotImplementedError if the object couldnt be printed
        '''
        if isinstance(x, Object):
            return self.print_object(x)
        if isinstance(x, View):
            return self.print_view(x)
        raise NotImplementedError



    def print_object(self, Object obj):
        if isinstance(obj, Expr):
            return self.print_expr(obj)

        if isinstance(obj, SymbolNumeric):
            return self.print_symbol(obj)

        if isinstance(obj, Matrix):
            return self.print_matrix(obj)

        if isinstance(obj, Base):
            return self.print_base(obj)

        if isinstance(obj, Point):
            return self.print_point(obj)

        if isinstance(obj, Frame):
            return self.print_frame(obj)

        if isinstance(obj, Wrench3D):
            return self.print_wrench(obj)

        raise NotImplementedError



    def print_expr(self, Expr expr):
        # This method is used to print a expression
        raise NotImplementedError

    def print_symbol(self, SymbolNumeric symbol):
        # This method is used to print a numeric symbol
        raise NotImplementedError

    def print_matrix(self, Matrix matrix):
        # This method is used to print a matrix (including vectors and tensors)
        raise NotImplementedError

    def print_base(self, Base base):
        # This method is used to print a base
        raise NotImplementedError

    def print_point(self, Point point):
        # This method is used to print a point
        raise NotImplementedError

    def print_frame(self, Frame frame):
        # This method is used to print a frame (also solids)
        raise NotImplementedError

    def print_wrench(self, Wrench3D wrench):
        # This method is used to print a wrench
        raise NotImplementedError




    def print_view(self, View view):
        # This method is used to print views
        if isinstance(view, TableView):
            return self.print_table_view(view)
        raise NotImplementedError


    def print_table_view(self, TableView table_view):
        raise NotImplementedError









######## Class ConsolePrinter ########


cdef class ConsolePrinter(Printer):
    '''
    Specialization of the class Printer to print objects in terminal mode.
    '''

    cpdef print_expr(self, Expr expr):
        # This method is used to print a expression

        cdef c_ginac_printer* c_printer = new c_ginac_python_printer(c_sstream())
        expr._c_handler.print(c_deref(c_printer))
        x = (<bytes>(<c_sstream*>&c_printer.s).str()).decode()
        del c_printer

        try:
            # Try to format the expression as a number (remove decimals if its integer)
            x = float(x)
            if floor(x) == x:
                x = floor(x)
            else:
                x = round(x, 4)
            return str(x)
        except:
            # Otherwise, returns the whole expression as-is
            return x



    cpdef print_symbol(self, SymbolNumeric symbol):
        # This method is used to print numeric symbols
        return f'{symbol.get_name()} = {round(symbol.get_value(), 4)}'



    cpdef print_matrix(self, Matrix matrix):
        # This method is used to print matrices (including vectors and tensors)

        if isinstance(matrix, Vector3D):
            return self.print_vector(matrix)

        values = tuple(map(str, matrix.get_values()))
        n, m = matrix.get_shape()
        if m == 1:
            m, n = n, 1

        col_sizes = [max([len(values[i*m + j]) for i in range(0, n)])+1 for j in range(0, m)]
        delimiters = '[]' if n == 1 or m == 1 else '\u2502'*2

        lines = []
        for i in range(0, n):
            line = ' '.join([values[i*m + j].rjust(col_size) for j, col_size in zip(range(0, m), col_sizes)])
            line = delimiters[0] + line + ' ' + delimiters[1]
            lines.append(line)

        if n > 1 and m > 1:
            # Insert decoratives
            row_width = len(lines[0]) - 2
            head = '\u256d' + ' '*row_width + '\u256e'
            tail = '\u2570' + ' '*row_width + '\u256f'
            lines.insert(0, head)
            lines.append(tail)

        return '\n'.join(lines)



    cpdef print_vector(self, Vector3D vector):
        lines = map(str, vector)
        return '[\n' + ',\n'.join(lines) + '\n] ' + f'base "{vector.base.name}"'




    cpdef print_base(self, Base base):
        # This method is used to print bases

        s = f'Base {base.name}'

        if base.has_previous():
            ancestors = []
            prev = base.get_previous()
            ancestors.append(prev)
            while prev.has_previous():
                prev = prev.get_previous()
                ancestors.append(prev)

            s += ', ancestors: ' + ' -> '.join(map(attrgetter('name'), ancestors))

        return s



    cpdef print_wrench(self, Wrench3D wrench):
        # This method is used to print wrenches
        lines = [
            f'wrench "{wrench.name}"',
            f'force = {wrench.force}',
            f'moment = {wrench.moment}',
            f'point "{wrench.point.name}"'
        ]
        return '\n'.join(lines)




    cpdef print_table_view(self, TableView table_view):
        # This method is used to print table views
        return tabulate(table_view.data, table_view.headers, tablefmt='plain')



######## src/core/pyx/latex.pyx ########




######## Custom GiNaC latex print formatting ########


# This function will tell GiNaC how to format numeric values in latex format.
cdef void _c_ginac_print_numeric_latex(const c_numeric& num, const c_ginac_latex_printer& c, unsigned level):
    if not num.is_integer() and not num.is_rational() and not num.is_real():
        # For the moment, its supposed that we only work with integers, reals or rationals
        raise RuntimeError('Latex printing on numbers only supports integers, rationals and reals')

    if num.is_zero():
        c.s << 0
        return

    if num.is_rational():
        if num.denom().compare(c_numeric(1)) == 0:
            c.s << num.numer()
        else:
            c.s << <c_string>b'\\frac{'
            c.s << num.numer()
            c.s << <c_string>b'}{'
            c.s << num.denom()
            c.s << <c_string>b'}'
        return

    cdef double value = num.to_double()
    cdef double intpart
    if c_modf(value, &intpart) == 0.0:
        c.s << <long>value
    else:
        c.s << value


# Register the function above in GiNaC using set_print_func
c_ginac_set_print_func[c_numeric, c_ginac_latex_printer](_c_ginac_print_numeric_latex)




######## Class LatexObjectPrinter ########


cdef class LatexPrinter(Printer):
    '''
    This is an specialization of the class Printer to print objects of this library
    in latex format.
    '''

    cdef _print_c_expr(self, c_ex expr):
        cdef c_ginac_printer* c_printer = new c_ginac_latex_printer(c_sstream())
        expr.print(c_deref(c_printer))
        text = (<bytes>(<c_sstream*>&c_printer.s).str()).decode()
        del c_printer
        return text


    cpdef print_expr(self, Expr expr):
        # This method is used to print a expression
        return self._print_c_expr(expr._c_handler)



    cpdef print_symbol(self, SymbolNumeric symbol):
        # This method is used to print a numeric symbol
        return symbol.get_tex_name() or r'\textrm{' + symbol.get_name()  + '}'



    cpdef print_matrix(self, Matrix matrix):
        # This method is used to print a matrix (including vectors and tensors)
        #s = repr(self._print_c_expr(c_ex(matrix._get_c_handler().get_matrix())))
        values = tuple(map(to_latex, matrix))
        n, m = matrix.get_shape()
        lines = [' & '.join([to_latex(matrix.get(i, j)) for j in range(0, m)]) for i in range(0, n)]
        return r'\begin{bmatrix}' + '\n' + (r'\\' + '\n').join(lines) + '\n' + r'\end{bmatrix}'





######## Latex printing on IPython  ########


cpdef _print_latex_ipython(str text):
    '''
    This function displays the given latex text on IPython.
    :param text: The latex text to be displayed
    :type text: str or bytes
    :parm TypeError: If the given text is not string or bytes
    :raises ImportError: If the library IPython couldnt be loaded
    '''
    try:
        from IPython.display import display, Math
    except ImportError:
        raise ImportError('You must have installed IPython to render latex')
    display(Math(text))




######## Utility global functions ########


def to_latex(*args):
    '''
    Convert one or more objects in a single latex inline formula.
    Objects can be of any kind; numeric symbols, expressions, matrices, vectors and tensors are
    printed nicely. The rest of objects are converted to a string using the metamethod
    __str__ and wrapped in a latex textrm statement: '\\textrm{str(object))}'


        :Example:

        >> to_latex(new_param('a', tex_name='\\alpha'))
        '\\alpha'

        >> u, x = new_param('u', tex_name='\\upsilon'), new_param('x', tex_name=r'\chi')
        >> to_latex(u, x)
        '\\upsilon\:\\chi'

        >> to_latex(u, '\\times', x, '=', u * x)
        '\\upsilon\\:\\times\\:\\chi\\:=\\: \\upsilon \\chi'

        >> to_latex(new_matrix(shape=[3, 3]))
        '\\left(\\begin{array}{ccc}0&0&0\\\\0&0&0\\\\0&0&0\\end{array}\\right)'
    '''
    printer = LatexPrinter()
    def _to_latex(x):
        try:
            return printer.print(x)
        except NotImplementedError:
            return '\\textrm{' + str(x) + '}'

    return r'\:'.join(map(_to_latex, args))




def print_latex(*args):
    '''
    This method calls to_latex to convert the input arguments to an inline latex formula.
    Then, the formula is displayed on IPython.

    :raise ImportError: If IPython module couldnt be imported
    '''
    _print_latex_ipython(to_latex(*args))








######## Symbol latex name autogeneration ########

# This variable holds a mapping to translate the latin alphabet to greek (in latex)
# both upper and lowercase (its used by the method below)
# Note that 'r' prefix is used to tell python not to escape '\' characters: r'\' == '\\'
_latin_to_greek_latex = {
    'a': r'\alpha',
    'b': r'\beta',
    'c': r'\gamma',        'C': r'\Gamma',
    'd': r'\delta',        'D': r'\Delta',
    'e': r'\varepsilon',
    'h': r'\eta',
    'i': r'\iota',
    'k': r'\kappa',
    'l': r'\lambda',       'L': r'\Lambda',
    'm': r'\mu',
    'n': r'\nu',
    'p': r'\rho',
    's': r'\sigma',        'S': r'\Sigma',
    't': r'\tau',
    'u': r'\upsilon',      'U': r'\Upsilon',
    'x': r'\chi'
}


def _gen_latex_name(name):
    '''
    Generate a latex name for the symbol name specified (that is, when the user doesnt
    specify the symbol latex name explicitly to autogenerate it).

    * If the given name is a letter of the latin alphabet, it is translated to its
    corresponding greek letter in latex (if it has one):

        :Example:

        >>> gen_latex_name('a')
        '\\alpha'
        >>> gen_latex_name('U') #
        '\\Upsilon'

    * If the name satisfies the above condition but also has a suffix that consists
    of an optional underscore, followed by a number, its translated to latex as before and a subindex
    is added to it:

        :Example:

        >> get_latex_name('s_2')
        '\\sigma_2'
        >> gen_latex_name('s3')
        '\\sigma3'

    * If the name has more than one letter, the latex name is the given name
    wrapped in a textrm statement: '\\textrm{text}'

        :Example:

        >> gen_latex_name('foo')
        '\\textrm{foo}'

        # You can also add subindices to it:
        >> gen_latex_name('foo_2')
        '\\textrm{foo}_2'

    '''
    name = _parse_text(name)

    if isinstance(name, bytes):
        name = name.decode()

    result = match('^([a-zA-Z]+)_?(\d*)$', name)
    if not result:
        return (r'\textrm{' + name  + '}').encode()

    name, subindex = result.group(1), result.group(2)
    if name in _latin_to_greek_latex:
        name = _latin_to_greek_latex[name]
    else:
        name = r'\textrm{' + name + '}'

    return (name if not subindex else f'{name}_' + '{' + subindex + '}').encode()



######## src/core/pyx/numeric.pyx ########


######## Class NumericFunction ########

class NumericFunction:
    '''
    Instances of this class represents numerical functions and
    are returned by the method ``get_numeric_function``

    .. seealso:: :func:`get_numeric_function`

    '''

    ######## Constructor ########

    def __init__(self, atoms, outputs, globals=None):
        ## Validate input arguments

        # Validate atoms argument
        assert isinstance(atoms, dict)
        assert all(map(lambda key: isinstance(key, str) and key.isidentifier(), atoms.keys()))
        assert all(map(lambda value: isinstance(value, str) and value, atoms.values()))

        # Validate outputs argument
        assert isinstance(outputs, (list, tuple))
        output = tuple(outputs)
        assert output
        assert all(map(lambda output: isinstance(output, (list, tuple)), outputs))
        outputs = tuple(map(tuple, outputs))
        assert len(frozenset(map(len, outputs))) == 1
        assert outputs[0]
        for output in outputs:
            assert all(map(lambda item: isinstance(item, str), output)) and all(output)

        # Validate globals argument
        assert globals is None or isinstance(globals, dict)
        if globals is not None:
            assert all(map(lambda key: isinstance(key, str) and key.isidentifier(), globals.keys()))
        else:
            globals = {'sin': math.sin, 'cos': math.cos, 'tan': math.tan}


        # Initialize internal fields
        self._atoms = atoms
        self._outputs = outputs
        self._code = None
        self._globals = globals




    def _compile(self):
        # This private method is used to compile the internal numeric function
        lines = [f'{name} = {value}' for name, value in self.atoms.items()]

        if isinstance(self.outputs[0], tuple):
            lines.append(f'__output__ = [' + ', '.join(['[' + ', '.join(row) + ']' for row in self.outputs]) + ']')
        else:
            lines.append(f'__output__ = [{", ".join(self.outputs)}]')
        source = '\n'.join(lines)
        self._code = compile(source, '<string>', 'exec', optimize=2)




    ######## Getters ########

    def get_atoms(self):
        '''get_atoms() -> Dict[str, str]
        Get the atoms associated to this numeric function.

        :return: A dictionary where keys are atom names and the values are their
            expressions
        :rtype: Dict[str, str]

        '''
        return self._atoms

    def get_outputs(self):
        '''get_outputs() -> List[str]
        Get the list of output expressions for this numeric function

        :rtype: List[str]

        '''
        return self._outputs



    def get_globals(self):
        '''get_globals() -> Dict[str, Any]
        Get the global variables and functions used by this numeric function
        '''
        return self._globals





    ######## Export/Import  ########

    @classmethod
    def load_from_file(cls, filename):
        '''load_from_file(filename: str) -> NumericFunction
        Create a numeric function with the information provided by the file in the given
        path (previously created by the function ``save_to_file``)

        .. seealso::
            :func:`save_to_file`

        '''
        if not isinstance(filename, str):
            raise TypeError('filename must be a string')
        with open(filename, 'r') as file:
            data = json.load(file)
        try:
            return cls(**data)
        except TypeError:
            raise RuntimeError(f'Failed to load numeric function from "{filename}"')


    def save_to_file(self, filename):
        '''save_to_file(filename: str)
        Save this numeric function to a file.

        '''
        if not isinstance(filename, str):
            raise TypeError('filename must be a string')
        data = {
            'atoms': self.atoms,
            'outputs': self.outputs
        }
        with open(filename, 'w') as file:
            json.dump(data, file)



    ######## Function evaluation ########

    def __call__(self, *args, **kwargs):
        '''
        Evaluate this numeric function with the provided positional & keyword arguments
        '''
        if args:
            assert len(args) == 1
            inputs = args[0]
            assert isinstance(inputs, dict)
            assert all(map(lambda key: isinstance(key, str) and key, inputs.keys()))
        else:
            inputs = {}

        inputs.update(kwargs)
        assert all(map(lambda value: isinstance(value, float), inputs.values()))

        # Compile numeric function body if needed
        if self._code is None:
            self._compile()

        # Evaluate the function
        globals = {}
        globals.update(self._globals)
        globals.update(inputs)
        locals = {}

        exec(self._code, globals, locals)
        result = np.array(locals['__output__'], dtype=np.float64)
        return result



    ######## Properties ########


    @property
    def atoms(self):
        '''
        Only read property that returns the atoms of this numeric function

        :rtype: Dict[str, str]

        '''
        return self.get_atoms()

    @property
    def outputs(self):
        '''
        Only read property that returns the outputs of this numeric function
        '''
        return self.get_outputs()

    @property
    def globals(self):
        '''
        Only read property that returns the global variables ir functions used by
        this numeric function
        '''
        return self.get_globals()





    ######## Printing ########



######## src/core/pyx/classes/object.pyx ########





######## Mixin classes ########


class NamedObject(ABC):
    '''
    Objects with name inherit the properties and methods defined within this class:
    * Method get_name
    * Property name
    * Metamethod __eq__
    '''

    def get_name(self):
        '''get_name() -> str
        Get the name of the object
        :rtype: str
        '''
        cdef c_string c_name
        if isinstance(self, SymbolNumeric):
            c_name = (<SymbolNumeric>self)._c_handler.get_name()
        elif isinstance(self, Matrix):
            c_name = (<Matrix>self)._get_c_handler().get_name()
        elif isinstance(self, Base):
            c_name = (<Base>self)._c_handler.get_name()
        elif isinstance(self, Point):
            c_name = (<Point>self)._c_handler.get_name()
        elif isinstance(self, Frame):
            c_name = (<Frame>self)._c_handler.get_name()
        elif isinstance(self, Wrench3D):
            c_name = (<Wrench3D>self)._c_handler.get_name()
        elif isinstance(self, Drawing3D):
            c_name = (<Drawing3D>self)._c_handler.get_name()
        else:
            raise RuntimeError

        return (<bytes>c_name).decode()


    @property
    def name(self):
        '''
        Only read property that returns the name of the object
        :rtype: str
        '''
        return self.get_name()



    def __eq__(self, other):
        '''
        Compare the object against other:
        * An object with name is always different to an object without name.
        * An object with name is equal to another object with name if and only if their names are equal
        '''
        if self is other:
            return True
        return isinstance(other, NamedObject) and self.get_name() == other.get_name()





class LatexRenderable(ABC):
    '''
    Objects which can be rendered to latex inherit the properties and methods defined within this class:
    * Methods to_latex and print_latex
    * Property latex
    '''

    def to_latex(self):
        '''to_latex() -> str
        Get this object formatted to latex
        :rtype: str
        '''
        return LatexPrinter().print(self)


    def print_latex(self):
        '''print_latex()
        Print this object on Ipython in latex format
        '''
        _print_latex_ipython(self.to_latex())


    @property
    def latex(self):
        '''
        Only read property that returns this object formatted to latex
        :rtype: str
        '''
        return self.to_latex()





class GeometricObject(ABC):
    '''
    Objects defined within a geometric base inherit the properties and methods defined within this class:
    * Methods get_base, in_base
    * Property base
    '''

    def get_base(self):
        '''get_base() -> Base
        Get the base of the object.
        :rtype: Base
        '''
        cdef c_Base* c_base
        #Base(<Py_ssize_t>(<c_Vector3D*>self._get_c_handler()).get_Base())
        if isinstance(self, Vector3D):
            c_base = (<c_Vector3D*>(<Vector3D>self)._get_c_handler()).get_Base()
        elif isinstance(self, Tensor3D):
            c_base = (<c_Tensor3D*>(<Tensor3D>self)._get_c_handler()).get_Base()
        elif isinstance(self, Frame):
            c_base = (<Frame>self)._c_handler.get_Base()
        elif isinstance(self, Drawing3D):
            c_base = (<Drawing3D>self)._c_handler.get_Base()
        else:
            raise RuntimeError

        return Base(<Py_ssize_t>c_base)



    @property
    def base(self):
        '''
        Property that returns the base of the object. You can also use it as
        a setter to perform a base change operation.
        :rtype: Base
        '''
        return self.get_base()


    @base.setter
    def base(self, x):
        self.in_base(x)






######## Class Object ########


cdef class Object:
    '''
    This is the base class of Expr, SymbolNumeric, Base, Matrix, Vector and Point
    classes.
    It emulates multiple inheritance to the abstract classes defined above
    (NamedObject, LatexRenderable, GeometricObject)
    '''

    @property
    def _bases(self):
        # Returns all the abstract interfaces implemented by this instance
        return [cls for cls in (NamedObject, LatexRenderable, GeometricObject) if isinstance(self, cls)]

    @property
    def _inherited_methods(self):
        # Returns all the inherited methods from the abstract interfaces
        # implemented by this instance
        methods = {}
        for base in self._bases:
            for name, value in base.__dict__.items():
                if not name.startswith('_') and callable(value):
                    methods[name] = value
        return methods


    @property
    def _inherited_properties(self):
        # Returns all the inherited properties from the abstract interfaces
        # implemented by this instance
        props = {}
        for base in self._bases:
            for name, value in base.__dict__.items():
                if not name.startswith('_') and isinstance(value, property):
                    props[name] = value
        return props


    def __getattr__(self, key):
        # Attribute lookup metamethod overloading.
        if key in self._inherited_methods:
            # The attribute is a method defined in one of the abstract classes.
            return MethodType(self._inherited_methods[key], self)

        if key in self._inherited_properties:
            prop = self._inherited_properties[key]
            if hasattr(prop, 'fget'):
                # The attribute is a property with getter defined in one of the abstract
                # classes.
                return prop.fget(self)

        raise AttributeError(f"'{type(self).__name__}' object has no attribute '{key}'")


    def __setattr__(self, key, value):
        # This is a workaround for cython defined properties with setter
        cls = self.__class__
        if hasattr(cls, key) and hasattr(getattr(cls, key), '__set__'):
            fset = getattr(getattr(cls, key), '__set__')
            fset(self, value)
            return

        # Attribute setter metamethod overloading.
        if key in self._inherited_properties:
            prop = self._inherited_properties[key]
            if hasattr(prop, 'fset'):
                # The attribute is a property with setter defined in one of the abstract classes.
                # Invoke the setter with the given value.
                prop.fset(self, value)
                return
        object.__setattr__(self, key, value)


    def __dir__(self):
        entries = super().__dir__()
        # Add implemented properties & methods to dir entries
        entries.extend(self._inherited_methods)
        entries.extend(self._inherited_properties)
        return entries


    def __eq__(self, other):
        # Use NamedObject.__eq__ to compare this instance with the given object
        # if it implements the interface NamedObject
        if isinstance(self, NamedObject):
            return NamedObject.__eq__(self, other)
        # Otherwise, use default __eq__ implementation
        return super().__eq__(self, other)


    def __str__(self):
        # Print the object
        try:
            return ConsolePrinter().print(self)
        except NotImplementedError:
            return f'{self.__class__.__name__} object'


    def __repr__(self):
        return self.__str__()





######## Class ObjectsMapping ########

class ObjectsMapping(Mapping):
    '''
    Instances of this class are used to access objects by their names
    emulating a Python dictionary structure.
    They are returned by methods get_parameters, get_inputs, ... of the System
    class:

        :Example:

        >> new_param('a', 1), new_param('b', 2), new_param('c', 3)
        >> params = get_params()
        >> params['a']
        a = 1
        >> list(params)
        'a', 'b', 'c'
        >> 'b' in params
        True

    '''
    def __init__(self, getter, pgetter, checker):
        self._getter = getter
        self._pgetter = pgetter
        self._checker = checker


    def __getitem__(self, name):
        obj = self._getter(name)
        assert isinstance(obj, Object)
        return obj


    def __len__(self):
        objs = self._pgetter()
        assert isinstance(objs, Sized)
        return len(objs)


    def __iter__(self):
        objs = self._pgetter()
        assert isinstance(objs, Iterable)
        for obj in objs:
            assert isinstance(obj, NamedObject)
            yield obj.get_name()


    def __contains__(self, name):
        x = self._checker(name)
        assert isinstance(x, bool)
        return x


    def __bool__(self):
        return len(self) > 0



######## src/core/pyx/classes/system.pyx ########


######## Helper types, variables & methods ########

cdef void outError(const char* msg):
    # Redefinition of outError function (to suppress error messages)
    #print((<bytes>msg).decode())
    pass



# C type alias representing a list of numeric symbols (std::vector[symbol_numeric*])
ctypedef c_vector[c_symbol_numeric*] c_symbol_numeric_list


# All numeric symbol types
_symbol_types = frozenset(map(str.encode, (
    'coordinate', 'velocity', 'acceleration',
    'aux_coordinate', 'aux_velocity', 'aux_acceleration',
    'parameter', 'joint_unknown', 'input'
)))

# All symbol types that cannot be created by the user (they are generated
# automatically when other kind of symbols are created)
_derivable_symbol_types = frozenset(map(str.encode, (
    'velocity', 'acceleration', 'aux_velocity', 'aux_acceleration'
)))

# All geometric object types
_geom_types = frozenset(map(str.encode, (
    'matrix', 'vector', 'tensor', 'base', 'point', 'frame', 'solid', 'wrench', 'drawing'
)))




######## Class System ########


## Class which acts like a bridge between Python and C++ System class
cdef class _System:


    ######## C Attributes ########

    cdef c_System* _c_handler
    cdef bint _autogen_latex_names


    ######## Constructor & Destructor ########


    def __cinit__(self):
        # Initialize C++ System object
        self._c_handler = new c_System(outError)

        self._autogen_latex_names = True


    def __dealloc__(self):
        del self._c_handler




    ######## C Getters ########

    cdef void* _get_c_object(self, c_string name, c_string kind):
        '''
        Get the object with the given name & type defined within this system
        :param string name: Name of the symbol
        :param string kind: Type of object ('parameter', 'vector', 'matrix', ...)
        :returns: A generic C pointer to the object or NULL if not object with such
            name or type exists
        :rtype: void*
        '''
        if kind == b'coordinate':
            return <void*>self._c_handler.get_Coordinate(name)
        if kind == b'velocity':
            return <void*>self._c_handler.get_Velocity(name)
        if kind == b'acceleration':
            return <void*>self._c_handler.get_Acceleration(name)
        if kind == b'aux_coordinate':
            return <void*>self._c_handler.get_AuxCoordinate(name)
        if kind == b'aux_velocity':
            return <void*>self._c_handler.get_AuxVelocity(name)
        if kind == b'aux_acceleration':
            return <void*>self._c_handler.get_AuxAcceleration(name)

        if kind == b'parameter':
            return <void*>self._c_handler.get_Parameter(name)
        if kind == b'joint_unknown':
            return <void*>self._c_handler.get_Unknown(name)
        if kind == b'input':
            return <void*>self._c_handler.get_Input(name)

        if kind == b'base':
            return <void*>self._c_handler.get_Base(name)
        if kind == b'matrix':
            return <void*>self._c_handler.get_Matrix(name)
        if kind == b'vector':
            return <void*>self._c_handler.get_Vector3D(name)
        if kind == b'tensor':
            return <void*>self._c_handler.get_Tensor3D(name)
        if kind == b'point':
            return <void*>self._c_handler.get_Point(name)
        if kind == b'frame':
            return <void*>self._c_handler.get_Frame(name)
        if kind == b'solid':
            return <void*>self._c_handler.get_Solid(name)
        if kind == b'wrench':
            return <void*>self._c_handler.get_Wrench3D(name)
        if kind == b'drawing':
            return <void*>self._c_handler.get_Drawing3D(name)
        return NULL



    cdef bint _has_c_object(self, c_string name, c_string kind):
        '''
        Check if an object with the given name & type exists within this system
        :param string name: Name of the symbol
        :param string kind: Type of the object ('parameter', 'vector', 'matrix', ...)
        :returns: 1 if the object exists. 0 otherwise
        :rtype: bint
        '''
        return self._get_c_object(name, kind) != NULL



    cdef c_symbol_numeric_list _get_c_symbols(self, c_string kind):
        '''
        Get all symbols of the given type defined within this system
        :param kind: Kind of symbols to retrieve. e.g: 'parameter'
        :type kind: std::string
        :rtype: std::vector[symbol_numeric*]
        '''
        if kind == b'coordinate':
            return self._c_handler.get_Coordinates()
        if kind == b'velocity':
            return self._c_handler.get_Velocities()
        if kind == b'acceleration':
            return self._c_handler.get_Accelerations()
        if kind == b'aux_coordinate':
            return self._c_handler.get_AuxCoordinates()
        if kind == b'aux_velocity':
            return self._c_handler.get_AuxVelocities()
        if kind == b'aux_acceleration':
            return self._c_handler.get_AuxAccelerations()
        if kind == b'parameter':
            return self._c_handler.get_Parameters()
        if kind == b'input':
            return self._c_handler.get_Inputs()
        if kind == b'joint_unknown':
            return self._c_handler.get_Joint_Unknowns()



    cdef c_Matrix _get_c_symbols_matrix(self, c_string kind):
        '''
        Get the matrix for the symbols of the given type.
        :param string kind: Must be the type of symbols to include in the resulting matrix
        :rtype: Matrix
        '''
        if kind == b'coordinate':
            return self._c_handler.Coordinates()
        if kind == b'velocity':
            return self._c_handler.Velocities()
        if kind == b'acceleration':
            return self._c_handler.Accelerations()
        if kind == b'aux_coordinate':
            return self._c_handler.Aux_Coordinates()
        if kind == b'aux_velocity':
            return self._c_handler.Aux_Velocities()
        if kind == b'aux_acceleration':
            return self._c_handler.Aux_Accelerations()
        if kind == b'parameter':
            return self._c_handler.Parameters()
        if kind == b'input':
            return self._c_handler.Inputs()
        if kind == b'joint_unknown':
            return self._c_handler.Joint_Unknowns()




    cdef c_symbol_numeric_list _get_all_c_symbols(self):
        '''
        Get all symbols within this system
        :rtype: std::vector[symbol_numeric*]
        '''
        cdef c_vector[c_symbol_numeric_list] containers
        containers.push_back(self._c_handler.get_Coordinates())
        containers.push_back(self._c_handler.get_Velocities())
        containers.push_back(self._c_handler.get_Accelerations())
        containers.push_back(self._c_handler.get_AuxCoordinates())
        containers.push_back(self._c_handler.get_AuxVelocities())
        containers.push_back(self._c_handler.get_AuxAccelerations())
        containers.push_back(self._c_handler.get_Parameters())
        containers.push_back(self._c_handler.get_Inputs())
        containers.push_back(self._c_handler.get_Joint_Unknowns())

        cdef c_symbol_numeric_list symbols
        cdef size_t num_symbols = 0

        for container in containers:
            num_symbols += container.size()
        num_symbols += 1
        symbols.reserve(num_symbols)

        for container in containers:
            symbols.insert(symbols.end(), container.begin(), container.end())
        symbols.push_back(&self._c_handler.t)

        return symbols



    cdef c_vector[c_Base*] _get_c_bases(self):
        '''
        Get all bases defined within this system
        :rtype: std::vector[Base*]
        '''
        return self._c_handler.get_Bases()


    cdef c_vector[c_Matrix*] _get_c_matrices(self):
        '''
        Get all matrices defined within this system
        :rtype: std::vector[Matrix*]
        '''
        return self._c_handler.get_Matrixs()


    cdef c_vector[c_Vector3D*] _get_c_vectors(self):
        '''
        Get all vectors defined within this system
        :rtype: std::vector[Vector3D*]
        '''
        return self._c_handler.get_Vectors()


    cdef c_vector[c_Tensor3D*] _get_c_tensors(self):
        return self._c_handler.get_Tensors()


    cdef c_vector[c_Point*] _get_c_points(self):
        '''
        Get all points defined within this system
        :rtype: std::vector[Point*]
        '''
        return self._c_handler.get_Points()


    cdef c_vector[c_Frame*] _get_c_frames(self):
        return self._c_handler.get_Frames()


    cdef c_vector[c_Solid*] _get_c_solids(self):
        return self._c_handler.get_Solids()


    cdef c_vector[c_Wrench3D*] _get_c_wrenches(self):
        return self._c_handler.get_Wrenches()


    cdef c_vector[c_Drawing3D*] _get_c_drawings(self):
        return self._c_handler.get_Drawings()



    ######## Getters ########


    cpdef _get_symbol(self, name, kind=None):
        cdef c_symbol_numeric *c_symbol
        cdef c_symbol_numeric *x
        cdef c_symbol_numeric_list c_symbols

        name = _parse_name(name)
        if kind is not None:
            kind = _parse_symbol_type(kind)
            c_symbol = <c_symbol_numeric*>self._get_c_object(name, kind)
        else:
            c_symbols = self._get_all_c_symbols()
            c_symbol = NULL
            for x in c_symbols:
                if x.get_name() == <c_string>name:
                    c_symbol = x

        if c_symbol != NULL:
            return SymbolNumeric(<Py_ssize_t>c_symbol, self)

        if kind is None:
            raise IndexError(f'Symbol "{name.decode()}" not created yet')
        kind_title = kind.decode().replace("_", " ")
        if self._has_symbol(name):
            raise IndexError(f'Symbol "{name.decode()}" is not a {kind_title}')
        raise IndexError(f'{kind_title} "{name.decode()}" not created yet')



    cpdef _has_symbol(self, name, kind=None):
        cdef c_symbol_numeric_list c_symbols
        cdef c_symbol_numeric* x

        name = _parse_name(name)
        if kind is not None:
            kind = _parse_symbol_type(kind)
            return self._has_c_object(name, kind)

        c_symbols = self._get_all_c_symbols()
        for x in c_symbols:
            if x.get_name() == <c_string>name:
                return True
        return False


    cpdef _get_symbols_matrix(self, kind):
        cdef c_Matrix c_matrix = self._get_c_symbols_matrix(_parse_symbol_type(kind))
        return _matrix_from_c_value(c_matrix)



    cpdef _get_time(self):
        return SymbolNumeric(<Py_ssize_t>&self._c_handler.t, self)



    cpdef _get_base(self, name):
        name = _parse_name(name)
        cdef c_Base* c_base = <c_Base*>self._get_c_object(name, b'base')
        if c_base == NULL:
            raise IndexError(f'Base "{name.decode()}" doesnt exist')
        return Base(<Py_ssize_t>c_base)


    cpdef _get_matrix(self, name):
        name = _parse_name(name)
        cdef c_Matrix* c_matrix = <c_Matrix*>self._get_c_object(name, b'matrix')
        if c_matrix == NULL:
            raise IndexError(f'Matrix "{name.decode()}" doesnt exist')
        return _matrix_from_c(c_matrix)


    cpdef _get_vector(self, name):
        name = _parse_name(name)
        cdef c_Vector3D* c_vector = <c_Vector3D*>self._get_c_object(name, b'vector')
        if c_vector == NULL:
            raise IndexError(f'Vector "{name.decode()}" doesnt exist')
        return _vector_from_c(c_vector)


    cpdef _get_tensor(self, name):
        name = _parse_name(name)
        cdef c_Tensor3D* c_tensor = <c_Tensor3D*>self._get_c_object(name, b'tensor')
        if c_tensor == NULL:
            raise IndexError(f'Tensor "{name.decode()}" doesnt exist')
        return _tensor_from_c(c_tensor)



    cpdef _get_point(self, name):
        name = _parse_name(name)
        cdef c_Point* c_point = <c_Point*>self._get_c_object(name, b'point')
        if c_point == NULL:
            raise IndexError(f'Point "{name.decode()}" doesnt exist')
        return Point(<Py_ssize_t>c_point)


    cpdef _get_frame(self, name):
        name = _parse_name(name)
        cdef c_Frame* c_frame = <c_Frame*>self._get_c_object(name, b'frame')
        if c_frame == NULL:
            raise IndexError(f'Frame "{name.decode()}" doesnt exist')
        return Frame(<Py_ssize_t>c_frame)


    cpdef _get_solid(self, name):
        name = _parse_name(name)
        cdef c_Solid* c_solid = <c_Solid*>self._get_c_object(name, b'solid')
        if c_solid == NULL:
            raise IndexError(f'Solid "{name.decode()}" doesnt exist')
        return Solid(<Py_ssize_t>c_solid)


    cpdef _get_wrench(self, name):
        name = _parse_name(name)
        cdef c_Wrench3D* c_wrench = <c_Wrench3D*>self._get_c_object(name, b'wrench')
        if c_wrench == NULL:
            raise IndexError(f'Wrench "{name.decode()}" doesnt exist')
        return _wrench_from_c(c_wrench)


    cpdef _get_drawing(self, name):
        name = _parse_name(name)
        cdef c_Drawing3D* c_drawing = <c_Drawing3D*>self._get_c_object(name, b'drawing')
        if c_drawing == NULL:
            raise IndexError(f'Drawing {name.decode()} doesnt exist')
        return Drawing3D(<Py_ssize_t>c_drawing)




    cpdef _has_base(self, name):
        return self._has_c_object(_parse_name(name), b'base')

    cpdef _has_matrix(self, name):
        return self._has_c_object(_parse_name(name), b'matrix')

    cpdef _has_vector(self, name):
        return self._has_c_object(_parse_name(name), b'vector')

    cpdef _has_tensor(self, name):
        return self._has_c_object(_parse_name(name), b'tensor')

    cpdef _has_point(self, name):
        return self._has_c_object(_parse_name(name), b'point')

    cpdef _has_frame(self, name):
        return self._has_c_object(_parse_name(name), b'frame')

    cpdef _has_solid(self, name):
        return self._has_c_object(_parse_name(name), b'solid')

    cpdef _has_wrench(self, name):
        return self._has_c_object(_parse_name(name), b'wrench')

    cpdef _has_drawing(self, name):
        return self._has_c_object(_parse_name(name), b'drawing')



    cpdef _has_object(self, name):
        name = _parse_name(name)
        if self._has_symbol(name):
            return True
        if self._has_base(name):
            return True
        if self._has_matrix(name) or self._has_vector(name):
            return True
        if self._has_point(name) or self._has_frame(name):
            return True
        if self._has_solid(name) or self._has_wrench(name):
            return True
        if self._has_drawing(name):
            return True
        return False





    ######## Container getters ########


    cpdef _get_all_symbols(self):
        cdef c_symbol_numeric_list c_symbols = self._get_all_c_symbols()
        symbols = [SymbolNumeric(<Py_ssize_t>c_symbol, self) for c_symbol in c_symbols]
        return symbols


    cpdef _get_symbols(self, kind=None):
        if kind is None:
            return self._get_all_symbols()
        cdef c_symbol_numeric_list c_symbols = self._get_c_symbols(_parse_symbol_type(kind))
        symbols = [SymbolNumeric(<Py_ssize_t>c_symbol, self) for c_symbol in c_symbols]
        return symbols


    cpdef _get_bases(self):
        cdef c_vector[c_Base*] c_bases = self._c_handler.get_Bases()
        return [Base(<Py_ssize_t>c_base) for c_base in c_bases]

    cpdef _get_matrices(self):
        cdef c_vector[c_Matrix*] c_matrices = self._c_handler.get_Matrixs()
        return [_matrix_from_c(c_matrix) for c_matrix in c_matrices]

    cpdef _get_vectors(self):
        cdef c_vector[c_Vector3D*] c_vectors = self._c_handler.get_Vectors()
        return [_vector_from_c(c_vector) for c_vector in c_vectors]

    cpdef _get_tensors(self):
        cdef c_vector[c_Tensor3D*] c_tensors = self._c_handler.get_Tensors()
        return [_tensor_from_c(c_tensor) for c_tensor in c_tensors]

    cpdef _get_points(self):
        cdef c_vector[c_Point*] c_points = self._c_handler.get_Points()
        return [Point(<Py_ssize_t>c_point) for c_point in c_points]

    cpdef _get_frames(self):
        cdef c_vector[c_Frame*] c_frames = self._c_handler.get_Frames()
        return [Frame(<Py_ssize_t>c_frame) for c_frame in c_frames]

    cpdef _get_solids(self):
        cdef c_vector[c_Solid*] c_solids = self._c_handler.get_Solids()
        return [Solid(<Py_ssize_t>c_solid) for c_solid in c_solids]

    cpdef _get_wrenches(self):
        cdef c_vector[c_Wrench3D*] c_wrenches = self._c_handler.get_Wrenches()
        return [_wrench_from_c(c_wrench) for c_wrench in c_wrenches]

    cpdef _get_drawings(self):
        cdef c_vector[c_Drawing3D*] c_drawings = self._c_handler.get_Drawings()
        return [Drawing3D(<Py_ssize_t>c_drawing) for c_drawing in c_drawings]



    ######## C Constructors ########


    cdef c_symbol_numeric* _new_c_parameter(self, c_string name, c_string tex_name, double value):
        return self._c_handler.new_Parameter(name, tex_name, c_numeric(value))


    cdef c_symbol_numeric* _new_c_input(self, c_string name, c_string tex_name, double value):
        return self._c_handler.new_Input(name, tex_name, c_numeric(value))


    cdef c_symbol_numeric* _new_c_joint_unknown(self, c_string name, c_string tex_name, double value):
        return self._c_handler.new_Joint_Unknown(name, tex_name, c_numeric(value))


    cdef c_symbol_numeric* _new_c_aux_coordinate(self,
        c_string name,     c_string vel_name,     c_string acc_name,
        c_string tex_name, c_string vel_tex_name, c_string acc_tex_name,
        double   value,    double   vel_value,    double   acc_value):
        return self._c_handler.new_AuxCoordinate(
            name, vel_name, acc_name,
            tex_name, vel_tex_name, acc_tex_name,
            c_numeric(value), c_numeric(vel_value), c_numeric(acc_value))


    cdef c_symbol_numeric* _new_c_coordinate(self,
        c_string name,     c_string vel_name,     c_string acc_name,
        c_string tex_name, c_string vel_tex_name, c_string acc_tex_name,
        double   value,    double   vel_value,    double   acc_value):
        return self._c_handler.new_Coordinate(
            name, vel_name, acc_name,
            tex_name, vel_tex_name, acc_tex_name,
            c_numeric(value), c_numeric(vel_value), c_numeric(acc_value))





    ######## Constructors ########


    cpdef _new_symbol(self, kind, args, kwargs):
        # Validate & parse input arguments
        args = list(args)
        kind = _parse_symbol_type(kind)
        if kind in _derivable_symbol_types:
            raise ValueError(f'You cant create a {kind.decode().replace("_", " ")} symbol by hand')

        cdef c_symbol_numeric* c_symbol
        cdef c_symbol_numeric* vel_c_symbol
        cdef c_symbol_numeric* acc_c_symbol


        # Signature of the method depends on the type of symbol
        if kind in (b'parameter', b'input', b'joint_unknown'):
            # Parse optional arguments
            if not kwargs and len(args) == 2:
                if not isinstance(args[-1], (str, bytes)):
                    kwargs['value'] = args.pop()

            name, tex_name, value = _apply_signature(
                ['name', 'tex_name', 'value'],
                {'tex_name': b'', 'value': 0.0},
                args, kwargs
            )
            name = _parse_name(name, check_syntax=True)
            value = _parse_numeric_value(value)

            tex_name = _parse_text(tex_name)
            if not tex_name and self._autogen_latex_names:
                # Auto generate latex name
                tex_name = _gen_latex_name(name)


            # Check if a symbol with the name specified already exists
            if self._has_object(name):
                if self._has_symbol(name, kind):
                    # The symbol already exists and has the same type
                    # Only update its latex name and value

                    # Print a warning message
                    warn(f'{kind.decode().replace("_", " ")} "{name.decode()}" already exists. Updating only its latex name and value', UserWarning)

                    symbol = self._get_symbol(name, kind)
                    symbol.set_value(value)
                    symbol.set_tex_name(tex_name)
                    return symbol

                raise IndexError(f'Name "{name.decode()}" its already in use')


            # Apply a different constructor for each symbol type
            if kind == b'parameter':
                c_symbol = self._new_c_parameter(name, tex_name, value)
            elif kind == b'input':
                c_symbol = self._new_c_input(name, tex_name, value)
            elif kind == b'joint_unknown':
                c_symbol = self._new_c_joint_unknown(name, tex_name, value)

            return SymbolNumeric(<Py_ssize_t>c_symbol, self)


        elif kind.endswith(b'coordinate'):
            # Bind input arguments to signature

            if not kwargs and len(args) in range(1, 10):
                kwargs['name'] = args.pop(0)

                params = ['vel_name', 'acc_name', 'tex_name', 'vel_tex_name', 'acc_tex_name']
                while args and params and isinstance(args[0], (str, bytes)):
                    kwargs[params.pop(0)] = args.pop(0)

                params = ['value', 'vel_value', 'acc_value']
                while args and params:
                    kwargs[params.pop(0)] = args.pop(0)

            bounded_args = _apply_signature(
                ['name', 'vel_name', 'acc_name', 'tex_name', 'vel_tex_name', 'acc_tex_name', 'value', 'vel_value', 'acc_value'],
                {'vel_name': None, 'acc_name': None, 'tex_name': b'', 'vel_tex_name': b'', 'acc_tex_name': b'',
                'value': 0.0, 'vel_value': 0.0, 'acc_value': 0.0},
                args, kwargs
            )

            # Validate & parse coordinate names
            names = list(bounded_args[:3])
            names[0] = _parse_name(names[0], check_syntax=True)
            names[1:] = [_parse_name(name, check_syntax=True) if name is not None else (b'd'*k + names[0]) for k, name in enumerate(names[1:],1)]

            # Validate & parse latex names
            tex_names = [_parse_text(arg) for arg in bounded_args[3:6]]

            # Validate & parse values
            values = [_parse_numeric_value(arg) for arg in bounded_args[6:9]]

            # Auto generate latex
            if self._autogen_latex_names:
                if not tex_names[0]:
                    tex_names[0] = _gen_latex_name(names[0])
                if tex_names[0]:
                    tex_names[1:] = [tex_name or b'\\' + b'd'*k + b'ot{' + tex_names[0] + b'}' for k, tex_name in enumerate(tex_names[1:], 1)]


            # Check if the name of the coordinate or its components is already in use by other symbol
            symbol_types = [b'coordinate', b'velocity', b'acceleration']
            if kind.startswith(b'aux_'):
                symbol_types = [b'aux_' + symbol_type for symbol_type in symbol_types]

            if all(starmap(self._has_symbol, zip(names, symbol_types))):
                # The coordinate and its derivatives already exists.
                # Only update their values and latex names
                symbols = tuple(starmap(self._get_symbol, zip(names, symbol_types)))

                # Print a warning message
                warn(f'Coordinate "{names[0].decode()}" and its derivatives already exists. Updating only their values and latex names', UserWarning)

                for symbol, tex_name, value in zip(symbols, tex_names, values):
                    symbol.set_tex_name(tex_name)
                    symbol.set_value(value)

                return symbols


            for name in names:
                if self._has_object(name):
                    raise IndexError(f'Name "{name.decode()}" its already in use')


            # Apply a different constructor for each symbol type
            if kind.startswith(b'aux_'):
                c_symbol = self._new_c_aux_coordinate(names[0], names[1], names[2], tex_names[0], tex_names[1], tex_names[2], values[0], values[1], values[2])
                vel_c_symbol, acc_c_symbol = self._c_handler.get_AuxVelocity(names[1]), self._c_handler.get_AuxAcceleration(names[2])
            else:
                c_symbol = self._new_c_coordinate(names[0], names[1], names[2], tex_names[0], tex_names[1], tex_names[2], values[0], values[1], values[2])
                vel_c_symbol, acc_c_symbol = self._c_handler.get_Velocity(names[1]), self._c_handler.get_Acceleration(names[2])

            return SymbolNumeric(<Py_ssize_t>c_symbol, self), SymbolNumeric(<Py_ssize_t>vel_c_symbol, self), SymbolNumeric(<Py_ssize_t>acc_c_symbol, self)

        else:
            raise RuntimeError




    cpdef _new_base(self, name, args, kwargs):
        # Validate & parse base name
        name = _parse_name(name, check_syntax=True)

        # Check if a base with the given name already exists
        if self._has_object(name):
            raise IndexError(f'Name "{name.decode()}" its already in use')

        # Validate & parse previous base, rotation tupla and angle arguments
        args = list(args)

        if args:
            new_args = []
            if not isinstance(args[0], (str, bytes, Base)):
                new_args.append(None)
            else:
                new_args.append(args.pop(0))

            if len(args) > 2:
                rotation_tupla = args[:3]
                args = args[3:]
                new_args.append(rotation_tupla)
            new_args.extend(args)
            args = new_args

        previous, rotation_tupla, rotation_angle = _apply_signature(
            ['previous', 'rotation_tupla', 'rotation_angle'],
            {'previous': None, 'rotation_tupla': (0, 0, 0), 'rotation_angle': 0},
            args, kwargs
        )

        if previous is not None:
            if not isinstance(previous, Base):
                try:
                    previous = self._get_base(previous)
                except IndexError as e:
                    raise ValueError(*e.args)
        else:
            previous = self._get_base(b'xyz')

        if not isinstance(rotation_tupla, (Iterable, Matrix)):
            raise TypeError(f'Rotation tupla must be an iterable or a Matrix object')

        if len(rotation_tupla) != 3:
            raise ValueError(f'Rotation tupla must have exactly three components')

        rotation_tupla = tuple(rotation_tupla)
        rotation_tupla = tuple(map(Expr, rotation_tupla))
        rotation_angle = Expr(rotation_angle)

        # Finally create the base
        cdef c_ex a, b, c, d
        cdef c_Base* c_prev_base

        c_prev_base = (<Base>previous)._c_handler
        a = (<Expr>rotation_tupla[0])._c_handler
        b = (<Expr>rotation_tupla[1])._c_handler
        c = (<Expr>rotation_tupla[2])._c_handler
        d = (<Expr>rotation_angle)._c_handler

        return Base(<Py_ssize_t>self._c_handler.new_Base(name, c_prev_base.get_name(), a, b, c, d))



    cpdef _new_matrix(self, name, args, kwargs):
        # Validate & parse name argument
        name = _parse_name(name, check_syntax=True)

        # Check if an object with the same name already exists
        if self._has_object(name) and not self._has_matrix(name):
            raise IndexError(f'Name "{name.decode()}" its already in use')

        # Create the matrix
        matrix = Matrix(*args, **kwargs)
        cdef c_Matrix* c_matrix = (<Matrix>matrix)._get_c_handler()


        if self._has_matrix(name):
            # An existing matrix with the same name already exists.
            # Only update its values
            warn(f'Matrix "{name.decode()}" already exists. Only updating its values', UserWarning)
            _matrix = self._get_matrix(name)
            (<Matrix>_matrix)._get_c_handler().set_matrix(c_matrix.get_matrix())
            return _matrix


        # Register the matrix with the given name in the system
        c_matrix.set_name(name)
        self._c_handler.new_Matrix(c_matrix)
        (<Matrix>matrix)._owns_c_handler = False
        return matrix



    cpdef _new_vector(self, name, args, kwargs):
        # Validate & parse name argument
        name = _parse_name(name, check_syntax=True)

        # Check if a matrix with the same name already exists
        if self._has_object(name) and not self._has_vector(name):
            raise IndexError(f'Name "{name.decode()}" its already in use')

        # Create the vector
        kwargs['system'] = self
        vector = Vector3D(*args, **kwargs)
        cdef c_Vector3D* c_vector = <c_Vector3D*>vector._get_c_handler()
        cdef c_Vector3D* _c_vector

        if self._has_vector(name):
            # Vector with the same name already exists. Only update its values and base
            warn(f'Vector "{name.decode()}" already exists. Only updating its base & values', UserWarning)

            _vector = self._get_vector(name)
            _c_vector = <c_Vector3D*>(<Vector3D>_vector)._get_c_handler()
            _c_vector.set_Base(c_vector.get_Base())
            _c_vector.set_matrix(c_vector.get_matrix())

            return _vector

        # Register the matrix with the given name in the system
        c_vector.set_name(name)
        self._c_handler.new_Vector3D(c_vector)
        (<Vector3D>vector)._owns_c_handler = False

        return vector



    cpdef _new_tensor(self, name, args, kwargs):
        name = _parse_name(name)

        if self._has_object(name) and not self._has_tensor(name):
            raise IndexError(f'Name "{name.decode()}" its already in use')

        kwargs['system'] = self
        tensor = Tensor3D(*args, **kwargs)
        cdef c_Tensor3D* c_tensor = <c_Tensor3D*>(<Tensor3D>tensor)._get_c_handler()
        cdef c_Tensor3D* _c_tensor

        if self._has_tensor(name):
            # Vector with the same name already exists. Only update its values and base
            warn(f'Tensor "{name.decode()}" already exists. Only updating its base & values', UserWarning)

            _tensor = self._get_tensor(name)
            _c_tensor = <c_Tensor3D*>(<Tensor3D>_tensor)._get_c_handler()
            _c_tensor.set_Base(c_tensor.get_Base())
            _c_tensor.set_matrix(c_tensor.get_matrix())
            return _tensor


        c_tensor.set_name(name)
        self._c_handler.new_Tensor3D(c_tensor)
        (<Tensor3D>tensor)._owns_c_handler = False
        return tensor




    cpdef _new_point(self, name, args, kwargs):
        name = _parse_name(name, check_syntax=True)

        if self._has_object(name):
            raise IndexError(f'Name "{name.decode()}" its already in use')

        if len(args) < 2 and 'previous' not in kwargs:
            args = list(args)
            args.insert(0, 'O')

        previous, position = _apply_signature(
            ['previous', 'position'],
            {},
            args,
            kwargs
        )

        if not isinstance(previous, Point):
            previous = self._get_point(previous)

        if not isinstance(position, Vector3D):
            position = self._get_vector(position)

        cdef c_Point* c_prev_point = (<Point>previous)._c_handler
        cdef c_Vector3D* c_pos_vector = <c_Vector3D*>(<Vector3D>position)._c_handler
        cdef c_Point* c_point = self._c_handler.new_Point(name, c_prev_point, c_pos_vector)
        return Point(<Py_ssize_t>c_point)




    cpdef _new_frame(self, name, point, base=None):
        name = _parse_name(name, check_syntax=True)

        if self._has_object(name):
            raise IndexError(f'Name "{name.decode()}" its already in use')

        if not isinstance(point, Point):
            point = self._get_point(point)

        if base is not None:
            if not isinstance(base, Base):
                base = self._get_base(base)
        else:
            base = self._get_base('xyz')

        return Frame(<Py_ssize_t>self._c_handler.new_Frame(name, (<Point>point)._c_handler, (<Base>base)._c_handler))




    cpdef _new_solid(self, name, point, base, mass, CM, IT):
        name = _parse_name(name, check_syntax=True)

        if self._has_object(name):
            raise IndexError(f'Name "{name.decode()}" its already in use')

        if not isinstance(point, (str, Point)):
            raise TypeError('point argument must be an instance of the class Point or str')

        if not isinstance(point, Point):
            point = self._get_point(point)


        if not isinstance(base, (str, Base)):
            raise TypeError('base argument must be an instance of the class Base or str')

        if not isinstance(base, Base):
            base = self._get_base(base)


        if not isinstance(mass, (str, SymbolNumeric)):
            raise TypeError('mass argument must be an instance of the class SymbolNumeric or str')

        if not isinstance(mass, SymbolNumeric):
            mass = self._get_symbol(mass, kind=b'parameter')
        elif mass.get_type() != 'parameter':
            raise TypeError('mass must be a parameter symbol')


        if not isinstance(CM, (str, Vector3D)):
            raise TypeError('CM argument must be an instance of the class Vector3D or str')

        if not isinstance(CM, Vector3D):
            CM = self._get_vector(CM)


        if not isinstance(IT, (str, Tensor3D)):
            raise TypeError('IT argument must be an instance of the class Tensor3D or str')

        if not isinstance(IT, Tensor3D):
            IT = self._get_tensor(IT)

        return Solid(<Py_ssize_t>self._c_handler.new_Solid(
            name,
            (<Point>point)._c_handler,
            (<Base>base)._c_handler,
            (<SymbolNumeric>mass)._c_handler,
            <c_Vector3D*>(<Vector3D>CM)._get_c_handler(),
            <c_Tensor3D*>(<Tensor3D>IT)._get_c_handler()
        ))



    cpdef _new_wrench(self, name, force, moment, point, solid, type):
        name = _parse_name(name, check_syntax=True)

        if self._has_object(name):
            raise IndexError(f'Name "{name.decode()}" its already in use')

        if not isinstance(force, (Vector3D, str)):
            raise TypeError('Force must be a Vector3D or str object')

        if not isinstance(force, Vector3D):
            force = self._get_vector(force)


        if not isinstance(moment, (Vector3D, str)):
            raise TypeError('Moment must be a Vector3D or str object')

        if not isinstance(moment, Vector3D):
            moment = self._get_vector(moment)


        if not isinstance(point, (Point, str)):
            raise TypeError('Point must be a Point or str object')

        if not isinstance(point, Point):
            point = self._get_point(point)


        if not isinstance(solid, (Solid, str)):
            raise TypeError('Moment must be a Solid or str object')

        if not isinstance(solid, Solid):
            solid = self._get_solid(solid)

        type = _parse_text(type)


        return _wrench_from_c(self._c_handler.new_Wrench3D(
            name,
            c_deref(<c_Vector3D*>(<Vector3D>force)._get_c_handler()),
            c_deref(<c_Vector3D*>(<Vector3D>moment)._get_c_handler()),
            (<Point>point)._c_handler,
            <c_Solid*>(<Solid>solid)._c_handler,
            type
        ))



    cpdef _new_drawing(self, name, args, kwargs):

        # Parse and validate the name
        name = _parse_name(name, check_syntax=True)

        if self._has_object(name):
            raise IndexError(f'Name "{name.decode()}" its already in use')

        if not args:
            raise TypeError('Expected at least one positional parameter')

        args = list(args)

        # First positional argument must be a frame or vector
        x = args.pop(0)

        if isinstance(x, str):
            if not self._has_vector(x) and not self._has_frame(x) and not self._has_solid(x):
                raise TypeError
            if self._has_vector(x):
                x = self._get_vector(x)
            elif self._has_frame(x):
                x = self._get_frame(x)
            else:
                x = self._get_solid(x)

        elif not isinstance(x, (Vector3D, Frame)):
            raise TypeError('First argument must be a vector or frame')


        # Second positional argument must be a point if the first one is a vector.
        if isinstance(x, Vector3D):
            if not args:
                raise TypeError('Expected one more positional argument after vector')

            y = args.pop(0)
            if isinstance(y, str):
                y = self._get_point(y)
            elif not isinstance(y, Point):
                raise TypeError('Second argument after vector must be a Point object')


        # Parse file, scale and color arguments
        if args and isinstance(args[0], str) and 'file' not in kwargs:
            kwargs['file'] = args.pop(0)

        if len(args) > 2:
            if len(args) != 5:
                raise TypeError('Invalid number of color components (4 expected)')
            args, color = args[:-4], args[-4:]
            args.append(color)


        scale, color, file = _apply_signature(
            ['scale', 'color', 'file'],
            {'file': '', 'scale':1, 'color': (1, 0, 0, 1)},
            args, kwargs
        )
        if not isinstance(file, str):
            raise TypeError('file must be a string')

        scale = _parse_numeric_value(scale)

        try:
            if not isinstance(color, Iterable):
                raise TypeError
            color = tuple(map(_parse_numeric_value, color))
            if len(color) != 4:
                raise TypeError

        except TypeError | ValueError:
            raise TypeError('color must be a list of four numeric values')


        cdef c_Drawing3D* c_drawing
        cdef c_numeric r = c_numeric(<double>color[0])
        cdef c_numeric g = c_numeric(<double>color[1])
        cdef c_numeric b = c_numeric(<double>color[2])
        cdef c_numeric a = c_numeric(<double>color[3])
        cdef c_lst c_color
        cdef c_numeric c_scale = c_numeric(<double>scale)

        c_color.append(c_ex(r))
        c_color.append(c_ex(g))
        c_color.append(c_ex(b))
        c_color.append(c_ex(a))

        # Create drawing with vector+point, frame or solid.
        # Then set the color & scale
        if isinstance(x, Frame):
            c_drawing = self._c_handler.new_Drawing3D(
                name,
                (<Frame>x)._c_handler,
                c_scale
            )
            c_drawing.set_color(c_color)

        else:
            c_drawing = self._c_handler.new_Drawing3D(name,
                <c_Vector3D*>(<Vector3D>x)._get_c_handler(),
                (<Point>y)._c_handler,
                r, g, b, a
            )
            c_drawing.set_scale(c_scale)

        # Also set the file
        c_drawing.set_file(<bytes>file.encode())

        # Returned the created drawing object
        return Drawing3D(<Py_ssize_t>c_drawing)





    ######## Kinematic operations ########


    cpdef _reduced_base(self, a, b):
        if not isinstance(a, (str, Base)) or not isinstance(b, (str, Base)):
            raise TypeError('Input arguments must be Base or str objects')

        if not isinstance(a, Base):
            a = self._get_base(a)

        if not isinstance(b, Base):
            b = self._get_base(b)

        return Base(<Py_ssize_t>self._c_handler.Reduced_Base(
            (<Base>a)._c_handler,
            (<Base>b)._c_handler)
        )



    cpdef _reduced_point(self, a, b):
        if not isinstance(a, (str, Point)) or not isinstance(b, (str, Point)):
            raise TypeError('Input arguments must be Point or str objects')

        if not isinstance(a, Point):
            a = self._get_point(a)

        if isinstance(b, str):
            b = self._get_point(b)

        return Point(<Py_ssize_t>self._c_handler.Reduced_Point(
            (<Point>a)._c_handler,
            (<Point>b)._c_handler)
        )



    cpdef _pre_point_branch(self, a, b):
        if not isinstance(a, (str, Point)) or not isinstance(b, (str, Point)):
            raise TypeError('Input arguments must be Point or str objects')

        if not isinstance(a, Point):
            a = self._get_point(a)

        if isinstance(b, str):
            b = self._get_point(b)

        return Point(<Py_ssize_t>self._c_handler.Pre_Point_Branch(
            (<Point>a)._c_handler,
            (<Point>b)._c_handler)
        )




    cpdef _rotation_matrix(self, a, b):
        if not isinstance(a, (str, Base)) or not isinstance(b, (str, Base)):
            raise TypeError('Input arguments must be Base or str objects')

        if not isinstance(a, Base):
            a = self._get_base(a)

        if not isinstance(b, Base):
            b = self._get_base(b)

        return _matrix_from_c_value(self._c_handler.Rotation_Matrix(
            (<Base>a)._c_handler,
            (<Base>b)._c_handler
        ))



    cpdef _position_vector(self, a, b):
        if not isinstance(a, (str, Point)) or not isinstance(b, (str, Point)):
            raise TypeError('Input arguments must be Point or str objects')

        if not isinstance(a, Point):
            a = self._get_point(a)

        if isinstance(b, str):
            b = self._get_point(b)

        return _vector_from_c_value(self._c_handler.Position_Vector(
            (<Point>a)._c_handler,
            (<Point>b)._c_handler
        ))



    cpdef _angular_velocity(self, a, b):
        if not isinstance(a, (str, Base)) or not isinstance(b, (str, Base)):
            raise TypeError('Input arguments must be Base or str objects')

        if not isinstance(a, Base):
            a = self._get_base(a)

        if not isinstance(b, Base):
            b = self._get_base(b)

        return _vector_from_c_value(self._c_handler.Angular_Velocity(
            (<Base>a)._c_handler,
            (<Base>b)._c_handler
        ))



    cpdef _angular_velocity_tensor(self, a, b):
        if not isinstance(a, (str, Base)) or not isinstance(b, (str, Base)):
            raise TypeError('Input arguments must be Base or str objects')

        if not isinstance(a, Base):
            a = self._get_base(a)

        if not isinstance(b, Base):
            b = self._get_base(b)

        return _tensor_from_c_value(self._c_handler.Angular_Velocity_Tensor(
            (<Base>a)._c_handler,
            (<Base>b)._c_handler
        ))



    cpdef _velocity_vector(self, frame, point, solid=None):
        if not isinstance(frame, (str, Frame)):
            raise TypeError('frame must be an instance of Frame or str')

        if not isinstance(point, (str, Point)):
            raise TypeError('point must be an instance of Point or str')

        if solid is not None and not isinstance(solid, (str, Solid)):
            raise TypeError('solid must be None or either an instance of Solid or str')

        if not isinstance(frame, Frame):
            frame = self._get_frame(frame)

        if not isinstance(point, Point):
            point = self._get_point(point)

        if solid is not None and not isinstance(solid, Solid):
            solid = self._get_solid(solid)


        cdef c_Frame* c_frame = (<Frame>frame)._c_handler
        cdef c_Point* c_point = (<Point>point)._c_handler
        if solid is None:
            return _vector_from_c_value(self._c_handler.Velocity_Vector(c_frame, c_point))
        return _vector_from_c_value(self._c_handler.Velocity_Vector(c_frame, c_point, <c_Solid*>(<Solid>solid)._c_handler))



    cpdef _angular_acceleration(self, a, b):
        if not isinstance(a, (str, Base)) or not isinstance(b, (str, Base)):
            raise TypeError('Input arguments must be Base or str objects')

        if not isinstance(a, Base):
            a = self._get_base(a)

        if not isinstance(b, Base):
            b = self._get_base(b)

        return _vector_from_c_value(self._c_handler.Angular_Acceleration(
            (<Base>a)._c_handler,
            (<Base>b)._c_handler
        ))



    cpdef _acceleration_vector(self, frame, point, solid=None):
        if not isinstance(frame, (str, Frame)):
            raise TypeError('frame must be an instance of Frame or str')

        if not isinstance(point, (str, Point)):
            raise TypeError('point must be an instance of Point or str')

        if solid is not None and not isinstance(solid, (str, Solid)):
            raise TypeError('solid must be None or either an instance of Solid or str')

        if not isinstance(frame, Frame):
            frame = self._get_frame(frame)

        if not isinstance(point, Point):
            point = self._get_point(point)

        if solid is not None and not isinstance(solid, Solid):
            solid = self._get_solid(solid)


        cdef c_Frame* c_frame = (<Frame>frame)._c_handler
        cdef c_Point* c_point = (<Point>point)._c_handler
        if solid is None:
            return _vector_from_c_value(self._c_handler.Acceleration_Vector(c_frame, c_point))
        return _vector_from_c_value(self._c_handler.Acceleration_Vector(c_frame, c_point, <c_Solid*>(<Solid>solid)._c_handler))




    cpdef _twist(self, solid):
        if not isinstance(solid, (str, Solid)):
            raise TypeError('Input argument must be a Solid or str object')

        if not isinstance(solid, Solid):
            solid = self._get_solid(solid)
        return _wrench_from_c_value(self._c_handler.Twist(<c_Solid*>(<Solid>solid)._c_handler))




    cpdef _derivative(self, args, kwargs):
        cdef c_Vector3D* c_vector

        if not args:
            raise TypeError('Invalid number of inputs (expected at least 1 positional argument)')
        args = list(args)
        x = args.pop(0)

        if not isinstance(x, (Expr, Matrix)):
            raise TypeError('The first argument must be an expression, matrix or vector')

        if isinstance(x, (Expr, Matrix)) and not isinstance(x, Vector3D):
            if args or kwargs:
                raise TypeError('Invalid number of arguments (only 1 expected)')
            if isinstance(x, Expr):
                return _expr_from_c(self._c_handler.dt((<Expr>x)._c_handler))

            return _matrix_from_c_value(self._c_handler.Dt(c_deref(<c_Matrix*>(<Matrix>x)._get_c_handler())))

        else:
            c_vector = <c_Vector3D*>(<Vector3D>x)._get_c_handler()

            if len(args) + len(kwargs) > 1:
                raise TypeError('Invalid number of arguments (only 2 expected)')
            elif not args and not kwargs:
                return _vector_from_c_value(self._c_handler.dt(c_deref(c_vector)))

            if args:
                y = args[0]
                if not isinstance(y, (str, Base, Frame)):
                    raise TypeError('Second argument after the vector must be a Frame, Base or str object')
                if isinstance(y, str):
                    if not self._has_base(y) and not self._has_frame(y):
                        raise IndexError('There is no frame or base called "{y}"')
                    if self._has_base(y):
                        y = self._get_base(y)
                    else:
                        y = self._get_frame(y)
            else:
                key = next(iter(kwargs))
                if key not in ('base', 'frame'):
                    raise TypeError(f'Got an unexpected keyword argument "{key}"')
                y = next(iter(kwargs.values()))
                if key == 'base':
                    if not isinstance(y, (str, Base)):
                        raise TypeError('base must be a Base or str object')
                    if not isinstance(y, Base):
                        y = self._get_base(y)

                else:
                    if not isinstance(y, (str, Frame)):
                        raise TypeError('frame must be a Frame or str object')
                    if not isinstance(y, Frame):
                        y = self._get_frame(y)

            if isinstance(y, Base):
                return _vector_from_c_value(self._c_handler.Dt(c_deref(c_vector), (<Base>y)._c_handler))
            return _vector_from_c_value(self._c_handler.Dt(c_deref(c_vector), (<Frame>y)._c_handler))






    cpdef _jacobian(self, args, kwargs):
        if len(args) < 2:
            raise TypeError('Invalid number of inputs (expected at least 2 positional arguments)')

        args = list(args)
        x, y = args[:2]
        args = args[2:]

        if not isinstance(x, Matrix):
            raise TypeError('The first argument must be a matrix')

        if not isinstance(y, (Matrix, SymbolNumeric)):
            raise TypeError('The second argument after the matrix must be a matrix or a symbol')

        if isinstance(y, SymbolNumeric):
            if len(args) > 0:
                raise TypeError('Invalid number of inputs (expected at most 2 positional arguments)')

            if kwargs:
                raise TypeError('You cant pass keyword arguments after passing a matrix and a symbol as positional arguments')


            # Derivative of the matrix with respect a symbol
            return _matrix_from_c_value(
                self._c_handler.jacobian(
                    c_deref(<c_Matrix*>(<Matrix>x)._get_c_handler()),
                    c_deref(<c_symbol*>(<SymbolNumeric>y)._c_handler)
                )
            )

        # Derivative of the matrix with resspect another matrix
        if len(args) + len(kwargs) > 1:
            raise TypeError('Invalid number of inputs (expected at most 3 positional or keyword arguments)')

        if args or kwargs:
            if kwargs:
                key = next(iter(kwargs))
                if key != 'symmetric':
                    raise TypeError(f'Got an unexpected keyword argument "{key}"')
                symmetric = next(iter(kwargs.values()))
            else:
                symmetric = args[0]

            if not isinstance(symmetric, (Expr, int)):
                raise TypeError('symmetric argument must be an expression, bool or int')

            symmetric = Expr(symmetric)
        else:
            symmetric = Expr(0)

        return _matrix_from_c_value(
            self._c_handler.jacobian(
                c_deref(<c_Matrix*>(<Matrix>x)._get_c_handler()),
                c_deref(<c_Matrix*>(<Matrix>y)._get_c_handler()),
                (<Expr>symmetric)._c_handler
                )
        )





    cpdef _diff(self, x, symbol):

        if not isinstance(symbol, (str, SymbolNumeric)):
            raise TypeError('symbol must be a SymbolNumeric or str object')

        if isinstance(symbol, str):
            symbol = self._get_symbol(symbol)

        if not isinstance(x, (Expr, Matrix, Wrench3D)):
            raise TypeError('First argument must be a expression, matrix or wrench object')


        cdef c_symbol_numeric* c_symbol = (<SymbolNumeric>symbol)._c_handler

        if isinstance(x, Expr):
            # derivative between expression and symbol
            return _expr_from_c(self._c_handler.diff(
                    (<Expr>x)._c_handler,
                    c_deref(c_symbol)
                    ))

        if isinstance(x, Vector3D):
            # derivative between vector and symbol
            return _vector_from_c_value(self._c_handler.diff(
                c_deref(<c_Vector3D*>(<Vector3D>x)._get_c_handler()),
                c_deref(c_symbol)
            ))

        if isinstance(x, Tensor3D):
            # derivative between tensor and symbol
            return _tensor_from_c_value(self._c_handler.diff(
                c_deref(<c_Tensor3D*>(<Tensor3D>x)._get_c_handler()),
                c_deref(c_symbol)
            ))

        if isinstance(x, Matrix):
            # derivative between matrix and symbol
            return _matrix_from_c_value(self._c_handler.diff(
                c_deref((<Matrix>x)._get_c_handler()),
                c_deref(c_symbol)
            ))

        # derivative between wrench and symbol
        return _wrench_from_c_value(self._c_handler.diff(
            c_deref((<Wrench3D>x)._c_handler),
            c_deref(c_symbol)
        ))




    ######## Solid operations ########


    def _gravity_wrench(self, solid):
        if not isinstance(solid, (str, Solid)):
            raise TypeError('Input argument must be a Solid or str object')
        if isinstance(solid, str):
            solid = self._get_solid(solid)

        return _wrench_from_c(self._c_handler.Gravity_Wrench(<c_Solid*>(<Solid>solid)._c_handler))


    def _inertia_wrench(self, solid):
        if not isinstance(solid, (str, Solid)):
            raise TypeError('Input argument must be a Solid or str object')
        if isinstance(solid, str):
            solid = self._get_solid(solid)
        return _wrench_from_c(self._c_handler.Inertia_Wrench(<c_Solid*>(<Solid>solid)._c_handler))





    ######## Numeric evaluation ########


    cpdef _evaluate(self, func):
        if not isinstance(func, NumericFunction):
            raise TypeError('Input argument must be a numeric function')

        cdef c_symbol_numeric_list c_symbols = self._get_all_c_symbols()
        return func(dict(zip([(<bytes>c_symbol.get_name()).decode() for c_symbol in c_symbols], [c_symbol.get_value().to_double() for c_symbol in c_symbols])))





    ######## Mixin ########

    cpdef _set_autogen_latex_names(self, enabled):
        if not isinstance(enabled, bool):
            raise TypeError('Input argument should be a boolean value')
        self._autogen_latex_names = enabled

    cpdef _is_autogen_latex_names_enabled(self):
        return self._autogen_latex_names











######## Class SymbolsMapping ########


class SymbolsMapping(ObjectsMapping, SymbolsTableView):
    def __init__(self, system, kind=None):
        ObjectsMapping.__init__(self,
            partial(system._get_symbol, kind=kind),
            partial(system._get_symbols, kind=kind),
            partial(system._has_symbol, kind=kind)
        )
        SymbolsTableView.__init__(self, system, kind)





######## Class MatricesMapping ########

class MatricesMapping(ObjectsMapping, MatricesTableView):
    def __init__(self, system):
        ObjectsMapping.__init__(self,
            system._get_matrix,
            system._get_matrices,
            system._has_matrix
        )
        MatricesTableView.__init__(self, system)




######## Class VectorsMapping ########

class VectorsMapping(ObjectsMapping, VectorsTableView):
    def __init__(self, system):
        ObjectsMapping.__init__(self,
            system._get_vector,
            system._get_vectors,
            system._has_vector
        )
        VectorsTableView.__init__(self, system)




######## Class TensorsMapping ########

class TensorsMapping(ObjectsMapping, TensorsTableView):
    def __init__(self, system):
        ObjectsMapping.__init__(self,
            system._get_tensor,
            system._get_tensors,
            system._has_tensor
        )
        TensorsTableView.__init__(self, system)




######## Class BasesMapping ########

class BasesMapping(ObjectsMapping, BasesTableView):
    def __init__(self, system):
        ObjectsMapping.__init__(self,
            system._get_base,
            system._get_bases,
            system._has_base
        )
        BasesTableView.__init__(self, system)




######## Class PointsMapping ########

class PointsMapping(ObjectsMapping, PointsTableView):
    def __init__(self, system):
        ObjectsMapping.__init__(self,
            system._get_point,
            system._get_points,
            system._has_point
        )
        PointsTableView.__init__(self, system)



######## Class FramesMapping ########

class FramesMapping(ObjectsMapping, FramesTableView):
    def __init__(self, system):
        ObjectsMapping.__init__(self,
            system._get_frame,
            system._get_frames,
            system._has_frame
        )
        FramesTableView.__init__(self, system)




######## Class SolidsMapping ########

class SolidsMapping(ObjectsMapping, SolidsTableView):
    def __init__(self, system):
        ObjectsMapping.__init__(self,
            system._get_solid,
            system._get_solids,
            system._has_solid
        )
        SolidsTableView.__init__(self, system)



######## Class WrenchesMapping ########

class WrenchesMapping(ObjectsMapping, WrenchesTableView):
    def __init__(self, system):
        ObjectsMapping.__init__(self,
            system._get_wrench,
            system._get_wrenches,
            system._has_wrench
        )
        WrenchesTableView.__init__(self, system)



######## Class DrawingsMapping ########

class DrawingsMapping(ObjectsMapping, DrawingsTableView):
    def __init__(self, system):
        ObjectsMapping.__init__(self,
            system._get_drawing,
            system._get_drawings,
            system._has_drawing
        )
        DrawingsTableView.__init__(self, system)



######## src/core/pyx/classes/symbol.pyx ########




######## Class SymbolNumeric ########


cdef class SymbolNumeric(Object):
    '''
    Objects of this class can be used to perform math symbolic computation.

    .. note::
        Do not instantiate this class manually.
        Use the methods ``new_symbol``, ``new_parameter``, ``new_coordinate``, ...
        defined in the System class

        .. seealso:: :class:`System`

    '''

    ######## C Attributes  ########


    cdef c_symbol_numeric* _c_handler
    cdef object _owner



    ######## Constructor & Destructor  ########

    def __cinit__(self, Py_ssize_t ptr, _System owner=None):
        self._c_handler = <c_symbol_numeric*>ptr
        self._owner = owner


    ######## Getters ########


    cpdef double get_value(self):
        '''get_value() -> float
        :return: The numeric value of this symbol as a float value.

        :rtype: float

        '''
        return self._c_handler.get_value().to_double()


    cpdef get_tex_name(self):
        '''get_tex_name() -> str
        Get the name in latex of this symbol

        :rtype: str

        '''
        return (<bytes>self._c_handler.print_TeX_name()).decode()


    def get_owner(self):
        '''get_owner() -> System
        Get the system where this numeric symbol was created

        :rtype: System

        '''
        if self._owner is None:
            raise RuntimeError
        return self._owner


    def get_type(self):
        '''get_type() -> str
        Get the type of this symbol.

        :returns:
            One of the next values:
                'parameter', 'joint_unknown', 'input',
                'coordinate', 'velocity', 'acceleration',
                'aux_coordinate', 'aux_velocity', 'aux_acceleration'
                'time' (the last one only if this instance is the time symbol)

        :rtype: str

        '''
        owner = self.get_owner()
        if self == owner._get_time():
            return 'time'
        for symbol_type in _symbol_types:
            if self in owner._get_symbols(symbol_type):
                return symbol_type.decode()
        raise RuntimeError



    ######## Setters ########


    cpdef set_value(self, value):
        '''set_value(value: numeric)
        Assigns a new numeric value to this symbol.

        :param value: It must be the new numeric value to assign for this symbol
        :type value: numeric
        :raises TypeError: If value has an incorrect type
        '''
        self._c_handler.set_value(c_numeric(<double>_parse_numeric_value(value)))



    cpdef set_tex_name(self, tex_name):
        '''set_tex_name(tex_name: str)
        Changes the latex name of this symbol

        :param str tex_name: The new latex name
        :raise TypeError: If the input argument has an incorrect type
        '''
        self._c_handler.set_TeX_name(_parse_text(tex_name))




    ######## Properties  ########


    @property
    def value(self):
        '''
        Property that returns the numeric value of this symbol (as a float number). It also supports
        assignment.

        :rtype: float

        .. note:: It calls internally the methods ``get_value`` or ``set_value``

            .. seealso::
                :func:`get_value`
                :func:`set_value`
        '''
        return self.get_value()

    @value.setter
    def value(self, value):
        self.set_value(value)


    @property
    def tex_name(self):
        '''
        Property that returns the name in latex of this symbol. It also supports assignment.

        :rtype: str

        .. note:: It calls internally the methods ``get_tex_name`` or ``set_tex_name``

            .. seealso::
                :func:`get_tex_name`
                :func:`set_tex_name`
        '''
        return self.get_tex_name()


    @tex_name.setter
    def tex_name(self, tex_name):
        self.set_tex_name(tex_name)


    @property
    def owner(self):
        '''
        Property that returns the system where this symbol was created

        :rtype: System

        '''
        return self.get_owner()


    @property
    def type(self):
        '''
        Only read property that returns the kind of symbol

        :rtype: str

        '''
        return self.get_type()


    @property
    def kind(self):
        '''
        This is an alias of property "type"

        :rtype: str

        '''
        return self.get_type()



    ######## Arithmetic operations ########


    def __neg__(self):
        '''
        Negates this symbol. The result is a symbolic expression.
        :rtype: Expr
        '''
        return -Expr(self)


    def __pos__(self):
        '''
        Performs unary positive operation on this symbol.
        The result is a expression.
        :rtype: Expr
        '''
        return +Expr(self)


    def __add__(self, other):
        '''
        Performs the sum operation with another symbol. The result is a symbolic
        expression.
        :rtype: Expr
        .. note:: Sum operation can be performed between symbols and expressions, but
            this logic is implemented in Expr.__add__ metamethod
        '''
        return NotImplemented if isinstance(other, Expr) else Expr(self) + Expr(other)


    def __sub__(self, other):
        '''
        Performs the subtraction operation with another symbol. The result is a symbolic
        expression.
        :rtype: Expr
        .. note:: Subtraction operation can be performed between symbols and expressions, but
            this logic is implemented in Expr.__sub__ metamethod
        '''
        return NotImplemented if isinstance(other, Expr) else Expr(self) - Expr(other)


    def __mul__(self, other):
        '''
        Multiplies this symbol with another. The result is a symbolic expression.
        :rtype: Expr
        .. note:: Symbols can be multiplied with matrices (or its subclasses) and expressions, but this is implemented
            in the metamethods Expr.__mul__, Matrix.__mul__, Vector3D.__mul__ and Tensor3D.__mul__
        '''
        return NotImplemented if isinstance(other, (Expr, Matrix, Wrench3D)) else Expr(self) * Expr(other)


    def __truediv__(self, other):
        '''
        :rtype: Expr
        Divides this symbol with another. The result is a symbolic expression.
        .. note:: Symbols can also divide or be divided by expressions. This
            functionality is implemented in Expr.__truediv__
        '''
        return NotImplemented if isinstance(other, Expr) else Expr(self) / other


    def __pow__(self, other, modulo):
        '''
        :rtype: Expr
        Raises this symbol by another one (the exponent could also be an expression).
        The result is an expression.
        '''
        return pow(Expr(self), other, modulo)




    ######## Number conversions ########


    def __float__(self):
        '''
        You can use the built-in float function to
        get the numeric value of this symbol:

            :Example:

            >>> a = new_param('a', 1.5)
            >>> float(a)
            1.5

        .. note::
            Its equivalent to ``get_value()``

            .. seealso:: :func:`get_value`
        '''
        return self.get_value()


    def __int__(self):
        '''
        You can use the built-in int function to
        get the numeric value of this symbol (as an integer):

            :Example:

            >>> a = new_param('a', 1.5)
            >>> int(a)
            1

        .. note::
            Its equivalent to ``int(get_value())``

            .. seealso:: :func:`get_value`
        '''
        return int(self.get_value())



    def __complex__(self):
        '''
        You can use the built-in complex function to
        get the numeric value of this symbol as a complex number (the imaginary
        part is set to zero):

            :Example:

            >>> a = new_param('a', 1.5)
            >>> complex(a)
            1.5+0j

        .. note::
            Its equivalent to ``complex(get_value())``

            .. seealso:: :func:`get_value`
        '''
        return complex(self._c_handler.get_value().real().to_double(), self._c_handler.get_value().imag().to_double())







NamedObject.register(SymbolNumeric)
LatexRenderable.register(SymbolNumeric)



######## src/core/pyx/classes/expression.pyx ########




######## Helper functions ########


cdef Expr _expr_from_c(c_ex x):
    # Converts GiNac::ex to Python class Expr instance
    expr = Expr()
    expr._c_handler = x
    return expr


cpdef str _print_expr_py(Expr atom_expr):
    # This routine prints a GiNac::ex as readable python code (its used to convert
    # atom expressions to valid python statements)
    cdef c_sstream out
    cdef c_ginac_printer* c_printer = new c_ginac_python_printer(out)
    atom_expr._c_handler.print(c_deref(c_printer))
    del c_printer
    return (<bytes>out.str()).decode()




######## Class Expr ########

cdef class Expr(Object):
    '''
    This class represents a symbolic expression.
    It implements a subset of the features provided by the C++ class GiNac::ex
    '''

    ######## C Attributes ########


    cdef c_ex _c_handler



    ######## Constructor ########


    def __cinit__(self, value=None):
        if value is not None:
            if not isinstance(value, (int, float, SymbolNumeric, Expr)):
                raise TypeError(f'"{type(value)} object cant be converted to an expression"')

            if isinstance(value, (int, float)) and floor(value) == value:
                self._c_handler = c_ex(<long>value)
            elif isinstance(value, float):
                self._c_handler = c_ex(<double>value)
            elif isinstance(value, SymbolNumeric):
                self._c_handler = c_ex(c_deref(<c_basic*>((<SymbolNumeric>value)._c_handler)))
            else:
                self._c_handler = (<Expr>value)._c_handler


    ######## Getters ########



    ######## Evaluation ########


    cpdef eval(self):
        return _expr_from_c(self._c_handler.eval())



    ######## Properties ########





    ######## Arithmetic unary operations ########


    def __neg__(self):
        '''
        Get this expression negated.
        :rtype: Expr
        '''
        return _expr_from_c(-self._c_handler)


    def __pos__(self):
        '''
        This method implements the unary positive operator for this expression.
        :rtype: Expr
        '''
        return _expr_from_c(+self._c_handler)




    ######## Arithmetic binary operations ########


    def __add__(left_op, right_op):
        '''
        Sum two expressions.
        :rtype: Expr
        :raise TypeError: If the operands have incorrect types
        .. note:: One of the operands can also be any object which can be converted to
            an expression (a numeric symbol or number)
        '''
        return _expr_from_c(Expr(left_op)._c_handler + Expr(right_op)._c_handler)


    def __sub__(left_op, right_op):
        '''
        Subtract two expressions.
        :rtype: Expr
        :raise TypeError: If the operands have incorrect types
        .. note:: One of the operands can also be any object which can be converted to
            an expression (a numeric symbol or number)
        '''
        return _expr_from_c(Expr(left_op)._c_handler - Expr(right_op)._c_handler)


    def __mul__(left_op, right_op):
        '''
        Computes the product of two expressions.
        :rtype: Expr
        :raise TypeError: If the operands have incorrect types
        .. note:: One of the operands can also be any object which can be converted to
            an expression (a numeric symbol or number)
        '''
        if isinstance(right_op, (Matrix, Wrench3D)):
            return NotImplemented
        return _expr_from_c(Expr(left_op)._c_handler * Expr(right_op)._c_handler)


    def __pow__(base, exp, modulo):
        '''
        Returns this expression raised to the power of another expression.
        :rtype: Expr
        :raise TypeError: If the operands have incorrect types
        .. note:: One of the operands (either the base or the exponent)
            can also be any object which can be converted to
            an expression (a numeric symbol or number)
        '''
        if modulo is not None:
            return NotImplemented
        return _expr_from_c(c_sym_pow(Expr(base)._c_handler, Expr(exp)._c_handler))



    def __truediv__(self, other):
        '''
        Returns this expression divided by another
        :rtype: Expr
        :raise TypeError: If the operands have incorrect types
        .. note:: One of the operands can also be any object which can be converted to
            an expression (a numeric symbol or number)
        '''
        if other == 0:
            raise ZeroDivisionError('Expression divided by zero')
        return _expr_from_c(Expr(self)._c_handler / Expr(other)._c_handler)




    ######## Arithmetic binary operations (inplace) ########


    def __iadd__(self, other):
        '''
        Perform an inplace sum operation with another expression
        :rtype: Expr
        :return: This instance
        :raise TypeError: If the operands have incorrect types
        .. note:: The input argument must be an expression or any object which can
            be converted to an expression (a numeric symbol or number)
        '''
        self._c_handler = self._c_handler + Expr(other)._c_handler
        return self


    def __isub__(self, other):
        '''
        Perform an inplace subtract operation with another expression
        :rtype: Expr
        :return: This instance
        :raise TypeError: If the operands have incorrect types
        .. note:: The input argument must be an expression or any object which can
            be converted to an expression (a numeric symbol or number)
        '''
        self._c_handler = self._c_handler - Expr(other)._c_handler
        return self


    def __imul__(self, other):
        '''
        Perform an inplace product operation with another expression
        :rtype: Expr
        :return: This instance
        :raise TypeError: If the operands have incorrect types
        .. note:: The input argument must be an expression or any object which can
            be converted to an expression (a numeric symbol or number)
        '''
        self._c_handler = self._c_handler * Expr(other)._c_handler
        return self

    def __itruediv__(self, other):
        '''
        Perform an inplace division operation with another expression
        :rtype: Expr
        :return: This instance
        :raise TypeError: If the operands have incorrect types
        .. note:: The input argument must be an expression or any object which can
            be converted to an expression (a numeric symbol or number)
        '''
        self._c_handler = self._c_handler / Expr(other)._c_handler
        return self




    ######## Comparision binary operations ########


    def __eq__(Expr self, other):
        if other == 0:
            return self._c_handler.is_zero()
        return self._c_handler.is_equal(Expr(other)._c_handler)



LatexRenderable.register(Expr)



######## Aliases for class Expr ########

Expression = Expr
Ex = Expr



######## src/core/pyx/classes/base.pyx ########




######## Class Base ########


cdef class Base(Object):
    '''
    Objects of this class represent geometric bases defined within a system.
    '''

    ######## C Attributes ########


    cdef c_Base* _c_handler




    ######## Constructor & Destructor ########


    def __cinit__(self, Py_ssize_t handler):
        self._c_handler = <c_Base*>handler




    ######## Getters ########


    cpdef get_previous_base(self):
        '''get_previous_base() -> Base
        Get the previous base.

        :returns: The previous base of this one if it has
        :rtype: Base
        :raises RuntimeError: If this base dont any previous one

        '''
        cdef c_Base* c_prev_base = self._c_handler.get_Previous_Base()
        if c_prev_base == NULL:
            raise RuntimeError(f'base {self.name} dont have a preceding one')
        return Base(<Py_ssize_t>c_prev_base)

    get_previous = get_previous_base



    cpdef bint has_previous_base(self):
        '''has_previous_base() -> bool
        Check if this base has a previous one.

        :returns: True if this base has a preceding base, False otherwise.
        :rtype: bool

        '''
        return self._c_handler.get_Previous_Base() != NULL

    has_previous = has_previous_base



    cpdef get_rotation_angle(self):
        '''get_rotation_angle() -> Expr
        Get the rotation angle of this base

        :rtype: Expr

        '''
        return _expr_from_c(self._c_handler.get_Rotation_Angle())



    cpdef get_rotation_tupla(self):
        '''get_rotation_tupla() -> Matrix
        Get the rotation tupla of this base

        :rtype: Matrix

        '''
        return _matrix_from_c_value(self._c_handler.get_Rotation_Tupla())



    cpdef get_rotation(self):
        '''get_rotation() -> Matrix
        Get the rotation transformation matrix of this base

        :rtype: Matrix

        '''
        return Matrix.rot(self.get_rotation_tupla(), self.get_rotation_angle())




    ######## Properties ########


    @property
    def previous_base(self):
        '''
        Read only property that returns the previous base

        :rtype: Base

        .. note::
            This calls internally to ``get_previous_base``

            .. seealso:: :func:`get_previous_base`
        '''
        return self.get_previous_base()


    @property
    def previous(self):
        '''
        This is an alias of previous_base property

        .. note::
            This calls internally to ``get_previous_base``

            .. seealso:: :func:`get_previous_base`

        '''
        return self.get_previous_base()


    @property
    def rotation_angle(self):
        '''
        Read only property that returns the rotation angle of this base

        :rtype: Expr

        .. note::
            This calls internally to ``get_rotation_angle``

            .. seealso:: :func:`get_rotation_angle`

        '''
        return self.get_rotation_angle()


    @property
    def rotation_tupla(self):
        '''
        Read only property that returns the rotation tupla of this base

        :rtype: Matrix

        .. note::
            This calls internally to ``get_rotation_tupla``

            .. seealso:: :func:`get_rotation_tupla`
        '''
        return self.get_rotation_tupla()



    @property
    def rotation(self):
        '''
        Read only property that returns the rotation transformation matrix of
        this base

        :rtype: Matrix

        .. note::
            This calls internally to ``get_rotation``

            .. seealso:: :func:`get_rotation`
        '''
        return self.get_rotation()



NamedObject.register(Base)



######## src/core/pyx/classes/matrix.pyx ########



######## Helper functions ########

cdef Matrix _matrix_from_c(c_Matrix* x):
    # Converts C++ Matrix object to Python class Matrix instance
    # (it doesnt make a copy, only stores the given pointer to the C++ matrix)
    mat = Matrix()
    mat._c_handler, mat._owns_c_handler = x, False
    return mat



cdef Matrix _matrix_from_c_value(c_Matrix x):
    # Converts C++ Matrix object to Python class Matrix instance
    # It performs a copy of the given C++ matrix
    mat = Matrix()
    cdef c_Matrix* c_mat = new c_Matrix(x.get_matrix())
    c_mat.set_name(x.get_name())

    mat._c_handler, mat._owns_c_handler = c_mat, True
    return mat





######## Class Matrix ########

cdef class Matrix(Object):
    '''
    Represents a 2D matrix of symbolic expressions of arbitrary sizes.
    '''

    ######## C Attributes ########


    cdef c_Matrix* _c_handler
    cdef bint _owns_c_handler



    ######## Constructor ########


    def __init__(self, values=None, shape=None):
        # Validate input arguments
        if values is None and shape is None:
            # Matrix 1x1 with a zero initialized by default
            self._c_handler = NULL
            return


        if shape is None and values is not None and not isinstance(values, (range, list, tuple, set, frozenset)):
            # Check if values is a numpy array
            if isinstance(values, np.ndarray):
                dtype = values.dtype
                if dtype not in (np.float64, np.int64):
                    dtype = np.float64
                m = np.array(values, dtype=dtype, copy=False, order='C')
                # Check numpy array dimensions
                if m.ndim not in (1, 2):
                    raise ValueError('Input numpy array must have one or two dimensions')
                shape = m.shape if m.ndim == 2 else (1, m.shape[0])
                values = m.tolist()


        # Validate & parse shape argument
        if shape is not None:
            if not isinstance(shape, (Iterable, int)):
                raise TypeError('Matrix shape must be an integer or iterable object')
            if isinstance(shape, int):
                shape = (shape, shape)
            else:
                shape = tuple(shape)
                if len(shape) == 1:
                    shape *= 2

            if len(shape) != 2 or not isinstance(shape[0], int) or not isinstance(shape[1], int):
                raise ValueError('Matrix shape must be a pair of numbers (num.rows x num.cols)')
            if shape[0] <= 0 or shape[1] <= 0:
                raise ValueError('Matrix dimensions must be numbers greater than zero')


        if values is not None:
            # values must be a matrix or an iterable
            if not isinstance(values, Iterable):
                raise TypeError(f'Matrix values must be an iterable object')

            values = tuple(values)
            if len(values) == 0:
                raise ValueError(f'You must specify at least one value')
            if isinstance(values[0], Iterable):
                if not all(map(lambda x: isinstance(x, Iterable), values[1:])):
                    raise TypeError

                # value is a list of sublists with expressions
                values = tuple(map(tuple, values))

                # check that all subslits have the same size
                if not all(map(lambda x: len(x) == len(values[0]), values[1:])):
                    raise ValueError('All sublists must have the same size')

                if shape is None:
                    # compute shape from values
                    shape = (len(values), len(values[0]))
                values = tuple(chain.from_iterable(values))
                if len(values) == 0:
                    raise ValueError('You must specify at least one value')
            else:
                # values is a list of expressions
                if any(map(lambda x: isinstance(x, Iterable), values[1:])):
                    raise TypeError
                if shape is None:
                    # compute shape from values
                    shape = (1, len(values))
                if len(values) == 0:
                    raise ValueError('You must specify at least one value')

            if shape[0] * shape[1] != len(values):
                raise ValueError(f'Inconsistent number of values ({len(values)}) and shape ({shape[0]} x {shape[1]})')


        # set matrix shape
        self._c_handler = new c_Matrix(shape[0], shape[1])
        self._owns_c_handler = True

        if values is not None:
            # Assign values to the matrix
            for k, value in enumerate(map(Expr, values)):
                i, j = k // shape[1], k % shape[1]
                self._c_handler.set(i, j, (<Expr>value)._c_handler)



    def __dealloc__(self):
        if self._c_handler != NULL and self._owns_c_handler:
            del self._c_handler


    cdef c_Matrix* _get_c_handler(self) except? NULL:
        if self._c_handler == NULL:
            self._c_handler = new c_Matrix(1, 1)
            self._owns_c_handler = True
        return self._c_handler




    @staticmethod
    def block(n, m, *args):
        '''block(n: int, m: int, ...) -> Matrix
        Creates a new matrix by merging a list of matrices together.

            :Example:

            >>> a = new_matrix('a', [[1, 2], [3, 4]])
            >>> b = new_matrix('b', [[5, 6], [7, 8]])
            >>> a
            ╭      ╮
            │ 1  2 │
            │ 3  4 │
            ╰      ╯
            >>> b
            ╭      ╮
            │ 5  6 │
            │ 7  8 │
            ╰      ╯
            >>> Matrix.block(1, 2, a, b)
            ╭            ╮
            │ 1  2  5  6 │
            │ 3  4  7  8 │
            ╰            ╯
            >>> Matrix.block(2, 1, a, b)
            ╭      ╮
            │ 1  2 │
            │ 3  4 │
            │ 5  6 │
            │ 7  8 │
            ╰      ╯
            >>> Matrix.block(2, 2, a, b, a, b)
            ╭            ╮
            │ 1  2  5  6 │
            │ 3  4  7  8 │
            │ 1  2  5  6 │
            │ 3  4  7  8 │
            ╰            ╯


        :param n: The number of blocks at the row dimension. Must be a value greater
            than zero
        :type n: int

        :param m: The number of blocks at the column dimension. Must be a value greater
            than zero.
        :type m: int

        :param args: The matrices to be merged:

            * The number of matrices specified must be equal to ``n*m``
            * All matrices in the same row block must have the same number of rows
            * All matrices in the same column block must have the same number of columns

        :rtype: Matrix


        '''
        if not isinstance(n, int) or n <= 0:
            raise TypeError('n must be a number greater than zero')

        if not isinstance(m, int) or m <= 0:
            raise TypeError('m must be a number greater than zero')

        if not all(map(lambda arg: isinstance(arg, Matrix), args)):
            raise TypeError('All input values passed as varadic arguments must be matrices')

        if n*m != len(args):
            raise ValueError('Inconsistent number of varadic arguments passed')

        # All matrices layed out on the same "row" must have the same number of rows
        if m > 1:
            for i in range(0, n):
                if len(frozenset(map(attrgetter('num_rows'), args[i*m:(i+1)*m]))) != 1:
                    raise TypeError('All matrices in a row must have the same number of rows')

        if n > 1:
            for j in range(0, m):
                if len(frozenset(map(attrgetter('num_cols'), [args[i*m+j] for i in range(0, n)]))) != 1:
                    raise TypeError('All matrices in a column must have the same number of rows')


        cdef c_vector[c_Matrix*] c_blocks
        c_blocks.reserve(len(args))
        for arg in args:
            c_blocks.push_back((<Matrix>arg)._get_c_handler())

        cdef c_Matrix* c_matrix = new c_Matrix(n, m, c_blocks)

        m = Matrix()
        (<Matrix>m)._c_handler = c_matrix
        (<Matrix>m)._owns_c_handler = True
        return m





    ######## Getters ########


    def get_shape(self):
        '''get_shape() -> Tuple[int, int]
        Get the shape of this matrix.

        :return: A tuple with two numbers (number of rows and columns)
        :rtype: Tuple[int, int]

        .. seealso:: :func:`get_num_rows` :func:`get_num_cols`
        '''
        return self._get_c_handler().rows(), self._get_c_handler().cols()


    def get_num_rows(self):
        '''get_num_rows() -> int
        Get the number of rows of this matrix

        :rtype: int

        '''
        return self._get_c_handler().rows()


    def get_num_cols(self):
        '''get_num_cols() -> int
        Get the number of columns of this matrix

        :rtype: int

        '''
        return self._get_c_handler().cols()


    def get_size(self):
        '''get_size() -> int
        Get the total number of items of this matrix (number of rows x number of columns)

        :rtype: int

        .. seealso:: :func:`get_num_rows` :func:`get_num_cols`

        '''
        return self.get_num_rows() * self.get_num_cols()


    def __len__(self):
        '''
        You can use the built-in method len to get the size of the matrix:

            :Example:

            >>> m = new_matrix('m', shape=[3,3])
            >>> m.get_size()
            9
            >>> len(m)
            9

        .. seealso:: :func:`get_size`
        '''
        return self.get_size()


    def __getattr__(self, key):
        try:
            return super().__getattr__(key)
        except AttributeError:
            pass

        if key not in ('get_module', 'get_skew', 'module', 'skew') or type(self) != Matrix:
            raise AttributeError(f'"Matrix" object has no attribute "{key}"')
        if self.get_size() != 3:
            raise AttributeError(f'Only 1x3 or 3x1 matrices have access to "{key}" method or property')

        values = self.get_values()
        cdef c_ex x = (<Expr>values[0])._c_handler
        cdef c_ex y = (<Expr>values[1])._c_handler
        cdef c_ex z = (<Expr>values[2])._c_handler
        return getattr(_vector_from_c_value(c_Vector3D(b'', x, y, z, NULL)), key)


    def __dir__(self):
        if self.get_size() != 3 or type(self) != Matrix:
            return super().__dir__()
        return super().__dir__() + ['get_module', 'get_skew', 'module', 'skew']




    ######## Accessing values ########


    def _parse_row_index(self, i):
        if not isinstance(i, int):
            raise TypeError('Matrix indices must be numbers')
        n = self.get_num_rows()
        if i < 0:
            i += n
        if i not in range(0, n):
            raise IndexError('Row index out of bounds')
        return i

    def _parse_col_index(self, j):
        if not isinstance(j, int):
            raise TypeError('Matrix indices must be numbers')
        m = self.get_num_cols()
        if j < 0:
            j += m
        if j not in range(0, m):
            raise IndexError('Column index out of bounds')
        return j


    def _parse_indices(self, i, j):
        return self._parse_row_index(i), self._parse_col_index(j)



    def get_values(self):
        '''get_values() -> List[Expr]
        Get all the items of this matrix

        :returns: A list containing all the items of this matrix, where the item
            at ith row and jth column will be located at i*num_cols + j index in that list

        :rtype: List[Expr]

        '''
        return list(self)



    def get(self, i, j=None):
        '''get(i: int[, j: int]) -> Expr
        Get an element of this matrix.
        If two arguments are passed, they will be interpreted as the row and column
        indices of the element to fetch:

            :Example:

            >>> m = new_matrix('m', [[0, 1], [2, 3]])
            >>> m
            ╭      ╮
            │ 0  1 │
            │ 2  3 │
            ╰      ╯
            >>> matrix.get(0, 0)
            0
            >>> matrix.get(1, 1)
            3

        You can pass also one index value if the matrix has only one row or
        column.
        The returned value will be the element at ith column or ith row respectively

            :Example:

            >>> m = new_matrix('m', [1, 3, 5, 7])
            >>> m
            [ 1  3  5  7 ]
            >>> m.get(2)
            5
            >>> m.transpose().get(3)
            7

        Indices can also be negative values:

            :Example:

            >>> m = new_matrix('m', [[1, 0, 0], [0, 2, 0], [0, 0, 3]])
            ╭         ╮
            │ 1  0  0 │
            │ 0  2  0 │
            │ 0  0  3 │
            ╰         ╯
            >>> m.get(2, 2)
            3
            >>> m.get(-1, -1)
            3

        :raise TypeError: If the indices passed are not valid
        :raise IndexError: If the indices are out of bounds
        '''
        if j is None:
            n, m = self.get_shape()
            if n > 1 and m > 1:
                raise TypeError('Missing column index')
            j = 0
            if n == 1:
                i, j = j, i

        i, j = self._parse_indices(i, j)
        return _expr_from_c(self._get_c_handler().get(i, j))



    def __getitem__(self, index):
        '''
        Implements the indexing operator. You can use it to fetch an element of
        the matrix by index.

            :Example:

            >>> m = new_matrix('m', [[1, 0, 0], [0, 2, 0], [0, 0, 3]])
            >>> m
            ╭         ╮
            │ 1  0  0 │
            │ 0  2  0 │
            │ 0  0  3 │
            ╰         ╯
            >>> m[1, 1]
            2

        .. note:: It calls internally to the method ``get``

            .. seealso:: :func:`get`
        '''
        if isinstance(index, tuple):
            if len(index) not in (1, 2):
                raise TypeError('Wrong number of indices')
            return self.get(*index)
        return self.get(index)





    ######## Changing values ########


    def set(self, i, *args):
        '''set(i: int[, j: int], value: Expr)
        Change the value of an element in the matrix.
        The arguments must be the indices of the element to change followed
        by its new value

            :Example:

            >>> m = new_matrix('m', [[0, 1], [2, 3]])
            >>> m
            ╭      ╮
            │ 0  1 │
            │ 2  3 │
            ╰      ╯
            >>> m.set(1, 1, 4)
            >>> m
            ╭      ╮
            │ 0  1 │
            │ 2  4 │
            ╰      ╯

        You could also specify just one index if the matrix has only one row or
        column.
        The element to be changed will be at ith column or row respectively

            :Example:

            >>> m = new_matrix('m', [1, 2, 3, 4])
            >>> m
            [ 1  2  3  4 ]
            >>> m.set(2, 0)
            >>> m
            [ 1  2  0  4 ]

        And indices can also be negative:

            :Example:

            >>> m = new_matrix('m', [[1, 2], [3, 4]])
            >>> m
            ╭      ╮
            │ 1  2 │
            │ 3  4 │
            ╰      ╯
            >>> m.set(-1, -1, 0)
            ╭      ╮
            │ 1  2 │
            │ 3  0 │
            ╰      ╯


        :raise TypeError: If the given indices or the new value for the element are not valid
        :raise IndexError: If the indices are out of bounds

        .. seealso:: :func:`get`

        '''
        if len(args) == 0:
            raise TypeError('Missing column index')
        if len(args) == 1:
            j, value = None, args[0]
        else:
            if len(args) > 2:
                raise TypeError('Wrong number of indices')
            j, value = args[0:2]

        if j is None:
            n, m = self.get_shape()
            if n > 1 and m > 1:
                raise TypeError('Missing column index')
            j = 0
            if n == 1:
                i, j = j, i

        i, j = self._parse_indices(i, j)
        if not isinstance(value, Expr):
            value = Expr(value)
        self._get_c_handler().set(i, j, (<Expr>value)._c_handler)



    def __setitem__(self, index, value):
        '''
        Implements the assignment indexing operator. You can use it to change
        the value of an specific element in the matrix.

            :Example:

            >>> m = new_matrix('m', [[1, 2], [3, 4]])
            >>> m
            ╭      ╮
            │ 1  2 │
            │ 3  4 │
            ╰      ╯
            >>> m[0, 1] = 0
            >>> m
            ╭      ╮
            │ 1  0 │
            │ 3  4 │
            ╰      ╯

        .. note:: It used the method ``set`` internally.

            .. seealso:: :func:`set`

        '''
        if isinstance(index, tuple):
            if len(index) != 2:
                raise TypeError('Wrong number of indices')
            i, j = index
            self.set(i, j, value)
        else:
            self.set(index, value)



    ######## Iteration ########


    def __iter__(self):
        '''
        This metamethod allow matrices to be iterated efficiently
        The returned iterator yields all the elements of this matrix

            :Example:

            >>> m = new_matrix('m', [[0, 1], [2, 3]])
            >>> [pow(el, 2)+1 for el in m]
            [1, 2, 5, 10]
            >>> list(m)
            [0, 1, 2, 3]
        '''
        n, m = self.get_shape()
        for i in range(0, n):
            for j in range(0, m):
                yield _expr_from_c(self._get_c_handler().get(i, j))


    def __reversed__(self):
        '''
        Same as __iter__ but returns the elements in reversed order.

        :Example:

        >>> m = new_matrix('m', [[0, 1], [2, 3]])
        >>> [pow(el, 2)+1 for el in reversed(m)]
        [10, 5, 2, 1]
        >>> list(reversed(m))
        [3, 2, 1, 0]

        .. seealso:: :func:`__iter__`

        '''
        n, m = self.get_shape()
        for i in reversed(range(0, n)):
            for j in reversed(range(0, m)):
                yield _expr_from_c(self._get_c_handler().get(i, j))



    ######## Arithmetic operations ########


    def __pos__(self):
        '''
        Get a matrix with their elements are the result of a unary positive operation
        of the elements of this matrix.
        :rtype: Matrix
        '''
        return _matrix_from_c_value(c_deref(self._get_c_handler()))

    def __neg__(self):
        '''
        Get a matrix with the elements of this one negated.
        :rtype: Matrix
        '''
        return _matrix_from_c_value(-c_deref(self._get_c_handler()))


    def __add__(Matrix self, other):
        '''
        Performs the sum operation between two matrices. The result
        is also a matrix.
        :rtype: Matrix
        :raise TypeError: If the operands are not matrices
        '''
        if not isinstance(other, Matrix):
            raise TypeError(f'Unsupported operand type for +: Matrix and {type(other).__name__}')
        return _matrix_from_c_value(c_deref(self._get_c_handler()) + c_deref((<Matrix>other)._get_c_handler()))


    def __sub__(Matrix self, other):
        '''
        Performs the subtraction operation between two matrices. The result
        is also a matrix.
        :rtype: Matrix
        :raise TypeError: If the operands are not matrices
        '''
        if not isinstance(other, Matrix):
            raise TypeError(f'Unsupported operand type for -: Matrix and {type(other).__name__}')
        return _matrix_from_c_value(c_deref(self._get_c_handler()) - c_deref((<Matrix>other)._get_c_handler()))


    def __mul__(left_op, right_op):
        '''
        If both operands are matrices, performs the matrix product.
        If one operand is a matrix and the other is an expression, performs
        the scalar product (each element is multiplied by the given expression).

        In both cases, the result is another matrix object.

        :rtype: Matrix
        :raises TypeError: If the input operands are not either two matrices or a matrix
            and a expression.
        '''
        if isinstance(left_op, Matrix) and isinstance(right_op, Matrix):
            return _matrix_from_c_value(
                c_deref((<Matrix>left_op)._get_c_handler()) * c_deref((<Matrix>right_op)._get_c_handler())
            )

        if not isinstance(left_op, Matrix) and not isinstance(right_op, Matrix):
            raise TypeError(f'Unsupported operand type for *: {type(left_op).__name__} and {type(right_op).__name__}')

        if isinstance(left_op, Matrix):
            right_op = Expr(right_op)
        else:
            left_op, right_op = right_op, Expr(left_op)
        return _matrix_from_c_value(c_deref((<Matrix>left_op)._get_c_handler()) * (<Expr>right_op)._c_handler)



    def __truediv__(Matrix self, other):
        '''
        Perform the scalar division operation. Elements of the matrix are divided by
        the given expression (second operand).

        :rtype: Matrix
        .. sealso:: __mul__
        '''
        if not isinstance(other, Expr):
            other = Expr(other)
        inverted = 1 / other
        return _matrix_from_c_value(c_deref(self._get_c_handler()) * (<Expr>inverted)._c_handler)




    ######## Recursive substitution ########


    def subs(self, symbols, repl):
        '''subs(symbols: Matrix | List[SymbolNumeric] | SymbolNumeric, repl: numeric) -> Matrix
        Performs a substitution of a vector of symbols or a symbol with a numeric value in all
        of the elements of the this matrix.


        * Replace a symbol with a numeric value:

            :Example:

            >>> a, b = new_param('a'), new_param('b')
            >>> m = Matrix([[a ** 2, a ** b], [b ** a, b ** 2]])
            >>> m
            ╭            ╮
            │ a**2  a**b │
            │ b**a  b**2 │
            ╰            ╯
            >>> m.subs(a, 0)
            ╭             ╮
            │ 0  (0.0)**b │
            │ 1      b**2 │
            ╰             ╯
            >>> m.subs(a, 1)
            ╭         ╮
            │ 1     1 │
            │ b  b**2 │
            ╰         ╯
            >>> m.subs(b, 1)
            ╭         ╮
            │ a**2  a │
            │    1  1 │
            ╰         ╯

        * Replace multiple symbols with a numeric value:

            :Example:

            >>> m = Matrix([[a ** 2, a - b], [b - a, b ** 2]])
            >>> m
            ╭            ╮
            │ a**2   a-b │
            │ -a+b  b**2 │
            ╰            ╯
            >>> m.subs([a, b], 2)
            ╭      ╮
            │ 4  0 │
            │ 0  4 │
            ╰      ╯
            >>> q = Matrix([a, b])
            >>> m.subs(q, 1)
            ╭      ╮
            │ 1  0 │
            │ 0  1 │
            ╰      ╯


        :param symbols: Must be a matrix or a list of symbols to be replaced. It can also
            be a single symbol.
            If its a matrix, it must have a single row or column.
        :type symbols: Matrix, List[SymbolNumeric], SymbolNumeric

        :param repl: The numeric value which will be used to replace the symbols with

        :type repl: numeric

        :rtype: Matrix

        '''

        try:
            if not isinstance(symbols, (Matrix, SymbolNumeric, Iterable)):
                raise TypeError

            if isinstance(symbols, SymbolNumeric):
                symbols = Matrix(values=[symbols])

            elif isinstance(symbols, Matrix):
                if symbols.get_num_rows() != 1 and symbols.get_num_cols() != 1:
                    raise ValueError('symbols matrix must have one single row or column')
                if symbols.get_num_rows() == 1:
                    symbols = symbols.transpose()

            else:
                symbols = tuple(symbols)
                if not symbols:
                    raise ValueError('You must specify at least one symbol')
                if not all(map(lambda symbol: isinstance(symbol, SymbolNumeric), symbols)):
                    raise TypeError
                symbols = Matrix(values=symbols).transpose()
        except TypeError:
            raise TypeError('symbols must be a Matrix, list of symbols or a symbol')

        repl = _parse_numeric_value(repl)

        return _matrix_from_c_value(c_subs(
            c_deref(self._get_c_handler()),
            c_deref((<Matrix>symbols)._get_c_handler()),
            repl
        ))





    ######## Numeric evaluation ########


    cpdef get_numeric_function(self):
        '''get_numeric_function() -> NumericFunction
        Generate a numeric function to evaluate the items of this matrix numerically

        The next example uses the matrix ``Phi`` generated by the example ``four_bar.py``

            :Example:

            >>> func = Phi.get_numeric_function()
            >>> func
            Numeric function
            >>> evaluate(func)
            [[-2.453589838486224], [2.2000000000000006]]
            >>> set_value('l4', 15)
            >>> evaluate(func)
            [[-15.853589838486224], [2.2000000000000006]]

        :type matrix: Matrix
        :rtype: NumericFunction

        '''
        cdef c_lst atom_lst
        cdef c_lst expr_lst

        # Optimize matrix list
        c_matrix_list_optimize(c_deref(<c_Matrix*>self._get_c_handler()), atom_lst, expr_lst)

        # Get the list of atoms with their expressions
        atoms = dict(zip([(<bytes>(c_ex_to[c_symbol](atom_lst.op(i))).get_name()).decode() for i in range(0, atom_lst.nops())],
                        [_print_expr_py(_expr_from_c(expr_lst.op(i))) for i in range(0, expr_lst.nops())]))

        # Get the matrix elements arranged as a list of lists (one list per row)
        n, m = self.shape
        outputs = [[_print_expr_py(self.get(i, j)) for j in range(0, m)] for i in range(0, n)]

        # Create the numeric function
        return NumericFunction(atoms, outputs)



    cpdef get_numeric_func(self):
        '''get_numeric_func() -> NumericFunction
        This is an alias of ``get_numeric_function``

        .. seealso:: :func:`get_numeric_function`

        '''
        return self.get_numeric_function()





    ######## Misc operations ########


    cpdef transpose(self):
        '''
        Get the transposed matrix

            :Example:

            >>> m = new_matrix('a', range(0, 9), shape=[3, 3])
            >>> m
            ╭         ╮
            │ 0  1  2 │
            │ 3  4  5 │
            │ 6  7  8 │
            ╰         ╯
            >>> m.transpose()
            ╭         ╮
            │ 0  3  6 │
            │ 1  4  7 │
            │ 2  5  8 │
            ╰         ╯

        :rtype: Matrix

        '''
        cdef c_Matrix c_mat = self._get_c_handler().transpose()
        return _matrix_from_c_value(c_mat)


    def get_transposed(self):
        '''
        Alias of transpose method

        .. seealso:: :func:`transpose`

        '''
        return self.transpose()





    ######## Properties ########


    @property
    def shape(self):
        '''
        Read only property that returns the shape of this matrix

        :rtype: Tuple[int, int]

        .. note:: It calls internally to ``get_shape``

            .. seealso:: :func:`get_shape`

        '''
        return self.get_shape()

    @property
    def num_rows(self):
        '''
        Read only property that returns the number of rows of this matrix

        :rtype: int


        .. note:: It calls internally to ``get_num_rows``

            .. seealso:: :func:`get_num_rows`
        '''
        return self.get_num_rows()

    @property
    def num_cols(self):
        '''
        Read only property that returns the number of columns of this matrix

        :rtype: int

        .. note:: It calls internally to ``get_num_cols``

            .. seealso:: :func:`get_num_cols`
        '''
        return self.get_num_cols()

    @property
    def size(self):
        '''
        Read only property that returns the total number of items on this matrix

        :rtype: int

        .. note:: It calls internally to ``get_size``

            .. seealso:: :func:`get_size`

        '''
        return self.get_size()


    @property
    def T(self):
        '''
        Read only property that returns the transposed matrix

        :rtype: Matrix

        .. note:: It calls internally to ``transpose``

            .. seealso:: :func:`transpose`

        '''
        return self.transpose()

    @property
    def transposed(self):
        '''
        Read only property that returns the transposed matrix

        :rtype: Matrix

        .. note:: It calls internally to ``transpose``

            .. seealso:: :func:`transpose`

        '''
        return self.transpose()


    @property
    def values(self):
        '''
        Read only property that returns all the items of this matrix as a regular list

        :rtype: List[Expr]

        .. note:: It calls internally to ``get_values``

            .. seealso:: :func:`get_values`

        '''
        return self.get_values()



    @property
    def numeric_function(self):
        '''
        Read only property that returns the numeric function to evaluate the items of
        this matrix numerically.

        :rtype: NumericFunction

        .. note:: It calls internally to ``get_numeric_function``

            .. seealso:: :func:`get_numeric_function`

        '''
        return self.get_numeric_function()



    @property
    def numeric_func(self):
        '''
        This is an alias of ``numeric_function`` property

        :rtype: NumericFunction

        .. seealso::
            :func:`numeric_function`
            :func:`get_numeric_function`

        '''
        return self.get_numeric_function()




    ######## Creation routines ########


    @classmethod
    def eye(cls, n):
        '''eye(n: int) -> Matrix
        Create a symbolic identity matrix of size nxn

            :Example:

            >>> Matrix.eye(3)
            ╭         ╮
            │ 1  0  0 │
            │ 0  1  0 │
            │ 0  0  1 │
            ╰         ╯
            >>> Matrix.eye(2)
            ╭      ╮
            │ 1  0 │
            │ 0  1 │
            ╰      ╯

        :rtype: Matrix

        '''
        if not isinstance(n, int) or n <= 0:
            raise TypeError('n must be a number greater than zero')
        return cls(np.eye(n))



    ######## Rotation matrices ########


    @classmethod
    def xrot(cls, phi):
        '''xrot(phi: Expr) -> Matrix
        Get a 3x3 matrix transformation which represents a rotation of ``phi`` radians
        with respect the x axis

            :Example:

            >>> a = new_param('a')
            >>> Matrix.xrot(a)
            ╭                    ╮
            │ 1       0        0 │
            │ 0  cos(a)  -sin(a) │
            │ 0  sin(a)   cos(a) │
            ╰                    ╯

        :type phi: Expr
        :rtype: Matrix

        '''
        return cls.rot([1, 0, 0], phi)


    @classmethod
    def yrot(cls, phi):
        '''yrot(phi: Expr) -> Matrix
        Get a 3x3 matrix transformation which represents a rotation of ``phi`` radians
        with respect the y axis

            :Example:

            >>> a = new_param('a')
            >>> Matrix.yrot(a)
            ╭                    ╮
            │  cos(a)  0  sin(a) │
            │       0  1       0 │
            │ -sin(a)  0  cos(a) │
            ╰                    ╯

        :type phi: Expr
        :rtype: Matrix

        '''
        return cls.rot([0, 1, 0], phi)



    @classmethod
    def zrot(cls, phi):
        '''zrot(phi: Expr) -> Matrix
        Get a 3x3 matrix transformation which represents a rotation of ``phi`` radians
        with respect the z axis

            :Example:

            >>> a = new_param('a')
            >>> Matrix.zrot(a)
            ╭                    ╮
            │ cos(a)  -sin(a)  0 │
            │ sin(a)   cos(a)  0 │
            │      0        0  1 │
            ╰                    ╯

        :type phi: Expr
        :rtype: Matrix

        '''
        return cls.rot([0, 0, 1], phi)



    @classmethod
    def rot(cls, axis, phi):
        '''rot(axis: Matrix, phi: Expr) -> Matrix
        Get a 3x3 matrix transformation which represents a rotation of ``phi`` radians
        with respect the given axis

            :Example:

            >>> x, y, z = new_param('x'), new_param('y'), new_param('z')
            >>> a = new_param('a')
            >>> Matrix.rot(axis=[x, y, z], phi=a)
            ╭                                                                                 ╮
            │ 1+(z**2+y**2)*(-1+cos(a))  -z*sin(a)-x*y*(-1+cos(a))   y*sin(a)-x*(-1+cos(a))*z │
            │  z*sin(a)-x*y*(-1+cos(a))  1+(z**2+x**2)*(-1+cos(a))  -y*(-1+cos(a))*z-x*sin(a) │
            │ -y*sin(a)-x*(-1+cos(a))*z  -y*(-1+cos(a))*z+x*sin(a)  1+(x**2+y**2)*(-1+cos(a)) │
            ╰                                                                                 ╯

        :type axis: Matrix
        :type phi: Expr
        :rtype: Matrix

        '''
        if not isinstance(axis, Matrix):
            axis = Matrix(shape=(1, 3), values=axis)
        elif axis.size != 3:
            raise TypeError('Axis must be a column or row matrix with three values')

        if not isinstance(phi, Expr):
            phi = Expr(phi)

        axis_skew = axis.get_skew()
        return cls.eye(3) + sin(phi) * axis_skew + (1 - cos(phi)) * (axis_skew * axis_skew)





NamedObject.register(Matrix)
LatexRenderable.register(Matrix)



######## src/core/pyx/classes/vector3D.pyx ########




######## Helper functions ########

cdef Vector3D _vector_from_c(c_Vector3D* x):
    # Converts C++ Vector3D object to Python class Vector3D instance
    # It doesnt make a copy of the contents of the C++ Vector
    v = Vector3D()
    v._c_handler, v._owns_c_handler = x, False
    return v


cdef Vector3D _vector_from_c_value(c_Vector3D x):
    # Converts C++ Vector3D object to Python class Vector3D instance
    # It performs a copy of the contents of the given C++ Vector3D
    v = Vector3D()
    v._c_handler = new c_Vector3D(x.get_Name(), x.get(0, 0), x.get(1, 0), x.get(2, 0), x.get_Base())
    (<c_Vector3D*>v._c_handler).set_System(x.get_System())
    v._owns_c_handler = True
    return v






######## Class Vector ########

cdef class Vector3D(Matrix):
    '''
    Represents a 3D vector defined within a base. Its a matrix with three rows
    and only one column.

    .. note::
        This class is not intented to instantiated manually. Use the
        method ``System.new_vector`` instead

        .. seealso:: :func:`System.new_vector`

    '''


    ######## Attributes ########


    ######## Constructor & Destructor ########

    def __init__(self, *args, **kwargs):
        if not args and not kwargs:
            # Construction without arguments is reserved for internal purposes
            self._c_handler = NULL
            return

        # Validate & parse arguments
        if args:
            args = list(args)

            try:
                if isinstance(args[-1], (str, Base)):
                    base, values = args[-1], args[:-1]
                    if len(values) not in (0, 1, 3):
                        raise TypeError
                    if len(values) != 1:
                        if len(values) == 0:
                            values = kwargs.pop('values', (0, 0, 0))
                        args = [values, base]
                else:
                    values = args
                    if len(values) not in (1, 3):
                        raise TypeError
                    if len(values) == 3:
                        args = [values]


            except TypeError:
                raise TypeError('You must specify exactly three values for the vector components')

        values, base, system = _apply_signature(
            ['values', 'base', 'system'],
            {'values': (0, 0, 0), 'base': 'xyz', 'system': None},
            args, kwargs
        )

        if not isinstance(base, (str, Base)):
            raise TypeError('base must be an instance of the class Base or a str')

        if not isinstance(system, _System):
            raise TypeError('system must be an instance of the class System')

        if isinstance(base, str):
            base = system.get_base(base)

        values = tuple(map(Expr, values))


        # Create the underline vector object
        cdef c_ex x = (<Expr>values[0])._c_handler
        cdef c_ex y = (<Expr>values[1])._c_handler
        cdef c_ex z = (<Expr>values[2])._c_handler
        cdef c_Base* c_base = (<Base>base)._c_handler

        cdef c_Vector3D* c_vector = new c_Vector3D(b'', x, y, z, c_base)

        self._c_handler = <c_Matrix*>c_vector
        self._owns_c_handler = True
        c_vector.set_System((<_System>system)._c_handler)




    cdef c_Matrix* _get_c_handler(self) except? NULL:
        if self._c_handler == NULL:
            raise RuntimeError
        return self._c_handler




    ######## Getters ########

    cpdef get_module(self):
        '''get_module() -> Expr
        Get the module of the vector

            :Example:

            >>> a, b, c = new_param('a'), new_param('b'), new_param('c')
            >>> v = new_vector('v', a, b, c)
            >>> v.get_module()
            (a**2+b**2+c**2)**(1/2)

        :rtype: Expr

        '''
        cdef c_ex c_expr = (<c_Vector3D*>self._get_c_handler()).get_module()
        return _expr_from_c(c_expr)


    cpdef get_skew(self):
        '''get_skew() -> Matrix
        Get the skew matrix of this vector.

            :Example:

            >>> a, b, c = new_param('a'), new_param('b'), new_param('c')
            >>> v = new_vector('v', a, b, c)
            >>> v.skew
            ╭            ╮
            │  0  -c   b │
            │  c   0  -a │
            │ -b   a   0 │
            ╰            ╯

        :rtype: Matrix

        '''
        cdef c_Matrix c_skew = (<c_Vector3D*>self._get_c_handler()).skew()
        return _matrix_from_c_value(c_skew)




    ######## Setters ########




    ######## Operations ########


    cpdef in_base(self, new_base):
        '''in_base(new_base: Base) -> Vector3D
        Performs a base change operation on this vector.

        :param base: The new base
        :type base: Base

        :return: A new vector which is the same as this but with its base changed

        :rtype: Vector3D

        '''
        if not isinstance(new_base, Base):
            raise TypeError('Input argument must be a Base object')
        return _vector_from_c_value((<c_Vector3D*>self._get_c_handler()).in_Base((<Base>new_base)._c_handler))



    def dot(self, other):
        '''dot(other: Vector3D) -> Expr
        Computes the dot product of two vectors.

            :Example:

            >>> a, b = new_param('a'), new_param('b')
            >>> v = new_vector('v', a, b, 1)
            >>> w = new_vector('w', 1, b, a)
            >>> v.dot(w)
            2*a+b**2

        :rtype: Expr
        :raise TypeError: If the input argument is not a vector
        '''
        if not isinstance(other, Vector3D):
            raise TypeError('Input argument must be a Vector3D')
        return _expr_from_c(
            c_deref(<c_Vector3D*>(<Vector3D>self)._get_c_handler()) *\
            c_deref(<c_Vector3D*>(<Vector3D>other)._get_c_handler())
        )


    def cross(self, other):
        '''cross(other: Vector3D) -> Vector3D
        Computes the cross product of two vectors.

            :Example:

            >>> a, b = new_param('a'), new_param('b')
            >>> v = new_vector('v', a, b, 1)
            >>> w = new_vector('w', 1, b, a)
            >>> v.cross(w)
            [ a*b-b  1.0-a**2  a*b-b ]
            >>> w.cross(v)
            [ -a*b+b  -1.0+a**2  -a*b+b ]

            :rtype: Vector3D
            :raise TypeError: If the input argument is not a vector
        '''
        if not isinstance(other, Vector3D):
            raise TypeError('Input argument must be a Vector3D')
        return _vector_from_c_value(
            c_deref(<c_Vector3D*>(<Vector3D>self)._get_c_handler()) ^\
            c_deref(<c_Vector3D*>(<Vector3D>other)._get_c_handler())
        )



    ######## Arithmetic operations ########


    def __pos__(self):
        '''
        Performs the unary positive operation on this vector. The result is another
        vector.
        :rtype: Vector3D
        '''
        return _vector_from_c_value(c_deref(<c_Vector3D*>self._get_c_handler()))

    def __neg__(self):
        '''
        Get this vector negated.
        :rtype: Vector3D
        '''
        return _vector_from_c_value(-c_deref(<c_Vector3D*>self._get_c_handler()))


    def __add__(Vector3D self, other):
        '''
        Perform the sum operation between two vectors. The result is another vector.
        :rtype: Vector3D
        '''
        if not isinstance(other, Vector3D):
            raise TypeError(f'Unsupported operand type for +: Vector3D and {type(other).__name__}')
        return _vector_from_c_value(
            c_deref(<c_Vector3D*>self._get_c_handler()) +\
            c_deref(<c_Vector3D*>(<Vector3D>other)._get_c_handler())
        )


    def __sub__(Vector3D self, other):
        '''
        Perform the subtraction operation between two vectors. The result is another vector.
        :rtype: Vector3D
        '''
        if not isinstance(other, Vector3D):
            raise TypeError(f'Unsupported operand type for -: Vector3D and {type(other).__name__}')
        return _vector_from_c_value(
            c_deref(<c_Vector3D*>self._get_c_handler()) -\
            c_deref(<c_Vector3D*>(<Vector3D>other)._get_c_handler())
        )


    def __mul__(left_op, right_op):
        '''
        Perform the product operation between two vectors or a vector and a expression.
        If the product is between two vectors, computes the dot product between them and the
        result is a expression.
        Otherwise, computes the scalar product of the vector with the given expression and
        the result is a vector.

        .. seealso:: dot
        '''
        if isinstance(left_op, Vector3D) and isinstance(right_op, Vector3D):
            # Dot product between vectors
            return left_op.dot(right_op)

        if not isinstance(left_op, Vector3D) and not isinstance(right_op, Vector3D):
            raise TypeError(f'Unsupported operand type for *: {type(left_op).__name__} and {type(right_op).__name__}')

        if isinstance(left_op, Vector3D):
            right_op = Expr(right_op)
        else:
            left_op, right_op = right_op, Expr(left_op)

        return _vector_from_c_value(
            (<Expr>right_op)._c_handler *\
            c_deref(<c_Vector3D*>((<Vector3D>left_op)._get_c_handler()))
        )



    def __truediv__(Vector3D self, other):
        '''
        Performs the scalar product between this vector and the given expression inverted.
        The result is also a vector.
        :rtype: Vector3D
        '''
        if not isinstance(other, Expr):
            expr = Expr(other)
        inverted_expr = 1 / expr

        return _vector_from_c_value(
            (<Expr>inverted_expr)._c_handler *\
            c_deref(<c_Vector3D*>(self._get_c_handler()))
        )



    def __xor__(Vector3D self, other):
        '''
        Performs the cross product of this vector with another.
        :rtype: Vector3D
        .. sealso:: cross
        '''
        if not isinstance(other, Vector3D):
            raise TypeError(f'Unsupported operand type for ^: Vector3D and {type(other).__name__}')
        return self.cross(other)




    ######## Properties ########

    @property
    def module(self):
        '''
        Only read property that returns the module of this vector.

        :rtype: Expr

        .. note:: This calls ``get_module`` internally.

            .. seealso:: get_module

        '''
        return self.get_module()

    @property
    def skew(self):
        '''
        Only read property that returns the skew matrix of this vector.

        :rtype: Matrix

        .. note:: This calls ``get_skew`` internally.

            .. seealso:: get_skew

        '''
        return self.get_skew()

    @property
    def x(self):
        '''
        Returns the first component of the vector. You can also use this property
        to assign a new value to it.

        :rtype: Expr

        '''
        return self.get(0)

    @x.setter
    def x(self, value):
        self.set(0, value)

    @property
    def y(self):
        '''
        Returns the second component of the vector. You can also use this property
        to assign a new value to it.

        :rtype: Expr

        '''
        return self.get(1)

    @y.setter
    def y(self, value):
        self.set(1, value)

    @property
    def z(self):
        '''
        Returns the third component of the vector. You can also use this property
        to assign a new value to it.

        :rtype: Expr

        '''
        return self.get(2)

    @z.setter
    def z(self, value):
        self.set(2, value)





GeometricObject.register(Vector3D)




######## Operations (global functions) ########


def dot(v, w):
    '''dot(v: Vector3D, w: Vector3D) -> Expr
    Computes the dot product of two vectors.

    :rtype: Expr
    :raise TypeError: If the input arguments are not vectors

        :Example:

        >>> a, b = new_param('a'), new_param('b')
        >>> v = new_vector('v', a, b, 1)
        >>> w = new_vector('w', 1, b, a)
        >>> dot(v, w)
        2*a+b**2

    .. note:: Its equivalent to v.dot(w) or w.dot(v)
    .. seealso:: Vector3D.dot
    '''
    if not isinstance(v, Vector3D) or not isinstance(w, Vector3D):
        raise TypeError('Input arguments must be Vector3D objects')
    return v.dot(w)


def cross(v, w):
    '''cross(v: Vector3D, w: Vector3D) -> Vector3D
    Computes the cross product between two vectors.

    :rtype: Vector3D
    :raise TypeError: If the input arguments are not vectors

        :Example:

        >>> a, b = new_param('a'), new_param('b')
        >>> v = new_vector('v', a, b, 1)
        >>> w = new_vector('w', 1, b, a)
        >>> cross(v, w)
        [ a*b-b  1.0-a**2  a*b-b ]
        >>> cross(w, v)
        [ -a*b+b  -1.0+a**2  -a*b+b ]


    .. note:: Its equivalent to v.cross(w)
    .. seealso:: Vector3D.cross
    '''
    if not isinstance(v, Vector3D) or not isinstance(w, Vector3D):
        raise TypeError('Input arguments must be Vector3D objects')
    return v.cross(w)




######## Aliases for class Vector3D ########

Vec3D = Vector3D



######## src/core/pyx/classes/tensor3D.pyx ########



######## Helper functions ########


cdef Tensor3D _tensor_from_c(c_Tensor3D* x):
    # Converts C++ Tensor3D object to Python class Tensor3D instance
    # It doesnt make a copy of the contents of the C++ tensor
    tensor = Tensor3D()
    tensor._c_handler, tensor._owns_c_handler = x, False
    return tensor



cdef Tensor3D _tensor_from_c_value(c_Tensor3D x):
    # Convert C++ Tensor3D object to Python class Tensor3D instance
    # It perform a copy of the contents of the given C++ Vector3D
    tensor = Tensor3D()
    tensor._c_handler = new c_Tensor3D(<c_Matrix>x, x.get_Base(), x.get_System())
    tensor._c_handler.set_name(x.get_name())
    tensor._owns_c_handler = True
    return tensor






######## Class Tensor3D ########

cdef class Tensor3D(Matrix):
    '''
    Instances of this class represents a tensor. Tensors are matrices
    3x3 defined within a geometric base.
    '''

    ######## Constructor ########

    def __init__(self, *args, **kwargs):
        if not args and not kwargs:
            # Construct without arguments is reserved for internal implementation purposes
            self._c_handler = NULL
            return

        # Validate & parse arguments
        if args:
            args = list(args)
            try:
                if isinstance(args[-1], (str, Base)):
                    base, values = args[-1], args[:-1]
                    if len(values) not in (0, 1, 9):
                        raise TypeError
                    if len(values) != 1:
                        if len(values) == 0:
                            values = tuple(repeat(0, 9))
                        args = [values, base]
                else:
                    values = args
                    if len(values) not in (1, 9):
                        raise TypeError
                    if len(values) == 9:
                        args = [values]

            except TypeError:
                raise TypeError('You must specify exactly nine values for the vector components')

        values, base, system = _apply_signature(
            ['values', 'base', 'system'],
            {'values': tuple(repeat(0, 9)), 'base': 'xyz', 'system': None},
            args, kwargs
        )


        if not isinstance(system, _System):
            raise TypeError(f'system must be a valid System object')

        if not isinstance(base, (str, Base)):
            raise TypeError('base must be an instance of the class Base or a str')

        if isinstance(base, str):
            base = system.get_base(base)


        values = Matrix(shape=(3, 3), values=values)


        # Call matrix initializer
        self._c_handler = new c_Tensor3D(
            c_deref((<Matrix>values)._get_c_handler()),
            (<Base>base)._c_handler,
            (<_System>system)._c_handler
        )
        self._owns_c_handler = True



    cdef c_Matrix* _get_c_handler(self) except? NULL:
        if self._c_handler == NULL:
            raise RuntimeError
        return self._c_handler



    ######## Getters ########


    ######## Operations ########


    cpdef in_base(self, new_base):
        '''in_base(new_base: Base) -> Tensor3D
        Performs a base change operation on this tensor.

        :param Base base: The new base
        :return: A new tensor which is the same as this but with its base changed

        :rtype: Tensor3D

        '''
        if not isinstance(new_base, Base):
            raise TypeError('Input argument must be a Base object')

        return _tensor_from_c_value((<c_Tensor3D*>self._get_c_handler()).in_Base((<Base>new_base)._c_handler))




    ######## Unary arithmetic operations ########


    def __neg__(self):
        '''
        Returns this tensor negated.
        '''
        return _tensor_from_c_value(
            Expr(-1)._c_handler *\
            c_deref(<c_Tensor3D*>self._get_c_handler())
        )


    def __pos__(self):
        '''
        Perform the unary positive operation on this tensor. The result is another
        tensor.
        '''
        return _tensor_from_c_value(c_deref(<c_Tensor3D*>self._get_c_handler()))




    ######## Binary arithmetic operations ########


    def __add__(Tensor3D self, other):
        '''
        Performs the sum operation between two tensors. The result is also a
        tensor.
        '''
        if not isinstance(other, Tensor3D):
            raise TypeError(f'Unsupported operand type for +: Tensor3D and {type(other).__name__}')

        return _tensor_from_c_value(
            c_deref(<c_Tensor3D*>self._get_c_handler()) +\
            c_deref(<c_Tensor3D*>(<Tensor3D>other)._get_c_handler())
        )


    def __sub__(Tensor3D self, other):
        '''
        Performs the subtraction operation between two tensors. The result is also
        a tensor.
        '''
        if not isinstance(other, Tensor3D):
            raise TypeError(f'Unsupported operand type for -: Tensor3D and {type(other).__name__}')

        return _tensor_from_c_value(
            c_deref(<c_Tensor3D*>self._get_c_handler()) -\
            c_deref(<c_Tensor3D*>(<Tensor3D>other)._get_c_handler())
        )


    def __mul__(left_op, right_op):
        '''
        Performs the product operation between two tensors, a tensor and vector or
        a tensor and a expression.
        * If both operands are tensors, the result is a tensor
        * If the first operand is a tensor and the second a vector, the result is a new
            vector
        * If one of the operands is a tensor and the other is an expression, perform
            the scalar product between them. The result is also a tensor.
        '''
        if isinstance(left_op, Tensor3D) and isinstance(right_op, Tensor3D):
            return _tensor_from_c_value(
                c_deref(<c_Tensor3D*>(<Tensor3D>left_op)._get_c_handler()) *\
                c_deref(<c_Tensor3D*>(<Tensor3D>right_op)._get_c_handler())
            )

        if not isinstance(left_op, Tensor3D) and not isinstance(right_op, Tensor3D):
            raise TypeError(f'Unsupported operand type for *: {type(left_op).__name__} and {type(right_op).__name__}')

        if isinstance(right_op, Vector3D):
            return _vector_from_c_value(
                c_deref(<c_Tensor3D*>(<Tensor3D>left_op)._get_c_handler()) *\
                c_deref(<c_Vector3D*>(<Vector3D>right_op)._get_c_handler())
            )

        if not isinstance(left_op, Tensor3D):
            left_op, right_op = right_op, left_op


        right_op = Expr(right_op)
        return _tensor_from_c_value(
            (<Expr>right_op)._c_handler *\
            c_deref(<c_Tensor3D*>(<Tensor3D>left_op)._get_c_handler())
        )


    def __truediv__(Tensor3D self, other):
        '''
        Performs the division operation between this tensor and a expression.
        The result is another expression.
        '''
        if not isinstance(other, Expr):
            expr = Expr(other)
        inverted_expr = 1 / expr

        return _tensor_from_c_value(
            (<Expr>inverted_expr)._c_handler *\
            c_deref(<c_Tensor3D*>(self._get_c_handler()))
        )



    ######## Properties ########










GeometricObject.register(Tensor3D)



######## src/core/pyx/classes/point.pyx ########


######## Class Point ########

cdef class Point(Object):
    '''
    Represents a geometric point defined within a system.
    '''


    ######## C Attributes ########


    cdef c_Point* _c_handler



    ######## Constructor & Destructor ########


    def __cinit__(self, Py_ssize_t handler):
        self._c_handler = <c_Point*>handler




    ######## Getters ########


    def get_position_vector(self):
        '''get_position_vector() -> Vector3D
        Get the position vector of this point

        :rtype: Vector3D

        '''
        return _vector_from_c(self._c_handler.get_Position_Vector())


    def get_position(self):
        '''get_position() -> Vector3D
        This is equivalent  to ``get_position_vector()``

        :rtype: Vector3D

        .. seealso:: :func:`get_position_vector`
        '''
        if not self.has_previous():
            raise RuntimeError
        return self.get_position_vector()


    def get_previous(self):
        '''get_previous() -> Point
        Get the previous point.

        :rtype: Point
        :raise RuntimeError: If this point dont have a preceding one

        '''
        cdef c_Point* c_prev_point = self._c_handler.get_Previous_Point()
        if c_prev_point == NULL:
            raise RuntimeError(f'Point {self.name} dont have a preceding one')
        return Point(<Py_ssize_t>c_prev_point)


    def has_previous(self):
        '''has_previous() -> bool
        Check if this point has a previous one

        :rtype: bool

        '''
        return self._c_handler.get_Previous_Point() != NULL


    ######## Properties ########

    @property
    def position_vector(self):
        '''
        Only read property that returns the position vector of this point

        :rtype: Vector3D

        .. note:: This calls internally to ``get_position_vector``

            .. seealso:: :func:`get_position_vector`

        '''
        return self.get_position_vector()


    @property
    def position(self):
        '''
        This is an alias of position_vector property

        :rtype: Vector3D

        .. note:: This calls internally to ``get_position_vector``

            .. seealso:: :func:`get_position_vector`
        '''
        return self.get_position()


    @property
    def previous(self):
        '''
        Only read property that returns the previous point.

        :rtype: Point
        :raise RuntimeError: If this point dont have a preceding one.

        .. note:: This calls internally to ``get_previous``

            .. seealso:: :func:`get_previous`
        '''
        return self.get_previous()





NamedObject.register(Point)



######## src/core/pyx/classes/frame.pyx ########


######## Class Frame ########

cdef class Frame(Object):
    '''
    Objects of this class represents geometric frames. They are defined with a
    point, scale and a base.
    '''


    ######## Attributes ########


    cdef c_Frame* _c_handler



    ######## Constructor ########

    def __cinit__(self, Py_ssize_t handler):
        self._c_handler = <c_Frame*>handler



    ######## Getters ########

    cpdef get_point(self):
        '''get_point() -> Point
        Get the point of this frame

        :rtype: Point

        '''
        return Point(<Py_ssize_t>self._c_handler.get_Point())


    cpdef get_scale(self):
        '''get_scale() -> float

        Get the scale of this frame

        :rtype: float
        '''
        return self._c_handler.get_scale().to_double()



    ######## Setters ########


    cpdef set_point(self, point):
        '''set_point(point: Point)
        Changes the point of this frame.

        :raise TypeError: If the input argument has not a valid type

        '''
        if not isinstance(point, Point):
            raise TypeError('Input argument must be a Point object')
        self._c_handler.set_Point((<Point>point)._c_handler)



    ######## Properties ########

    @property
    def point(self):
        '''
        Property that returns the point of this frame. It can also be used to
        assign a new point.

        :rtype: Point

        .. note::
            This uses internally the methods ``get_point`` and ``set_point``

            .. seealso:: :func:`get_point` :func:`set_point`

        '''
        return self.get_point()

    @point.setter
    def point(self, point):
        self.set_point(point)


    @property
    def scale(self):
        '''
        Read only property that returns the scale of this frame.

        :rtype: float

        .. note::
            This used internally the method ``get_scale``

            .. seealso:: :func:`get_scale`
        '''
        return self.get_scale()






NamedObject.register(Frame)
GeometricObject.register(Frame)



######## src/core/pyx/classes/solid.pyx ########



######## Class Solid ########

cdef class Solid(Frame):
    '''
    Objects of this class represent solids.
    '''

    ######## Getters ########


    cpdef get_CM(self):
        '''get_CM() -> Vector3D
        Get the center of mass of this solid.

        :rtype: Vector3D

        '''
        return _vector_from_c((<c_Solid*>self._c_handler).get_CM())


    cpdef get_IT(self):
        '''get_IT() -> Tensor3D
        Get the inertia tensor of this solid.

        :rtype: Tensor3D

        '''
        return _tensor_from_c((<c_Solid*>self._c_handler).get_IT())


    cpdef get_G(self):
        # TODO fix me
        return Point(<Py_ssize_t>(<c_Solid*>self._c_handler).get_G())


    cpdef get_mass(self):
        '''get_mass() -> SymbolNumeric
        Get the mass of this solid.

        :rtype: SymbolNumeric

        '''
        return SymbolNumeric(<Py_ssize_t>(<c_Solid*>self._c_handler).get_mass())



    ######## Setters ########


    ######## Properties ########


    @property
    def CM(self):
        '''
        Only read property that returns the center of mass of this solid.

        :rtype: Vector3D

        .. note:: This calls internally to `get_CM`

            .. seealso:: :func:`get_CM`

        '''
        return self.get_CM()


    @property
    def IT(self):
        '''
        Only read property that returns the intertia tensor of this solid.

        :rtype: Tensor3D

        .. note:: This calls internally to `get_IT`

            .. seealso:: :func:`get_IT`

        '''
        return self.get_IT()


    @property
    def G(self):
        return self.get_G()


    @property
    def mass(self):
        '''
        Only read property that returns the mass of this solid.

        :rtype: SymbolNumeric

        .. note:: This calls internally to `get_mass`

            .. seealso:: :func:`get_mass`

        '''
        return self.get_mass()



######## src/core/pyx/classes/wrench3D.pyx ########




cdef Wrench3D _wrench_from_c(c_Wrench3D* x):
    wrench = Wrench3D()
    wrench._c_handler, wrench._owns_c_handler = x, False
    return wrench


cdef Wrench3D _wrench_from_c_value(c_Wrench3D x):
    wrench = Wrench3D()
    wrench._c_handler = new c_Wrench3D(
        x.get_name(), x.get_Force(), x.get_Moment(), x.get_Point(),
        x.get_Solid(), x.get_Type()
    )
    wrench._owns_c_handler = True
    return wrench




cdef class Wrench3D(Object):
    '''
    An instance of this class represents a wrench which is attached to solid and
    has a force and momentum vectors.
    '''

    ######## Constructor ########

    cdef c_Wrench3D* _c_handler
    cdef bint _owns_c_handler



    ######## Constructor & Destructor ########

    def __cinit__(self):
        self._c_handler = NULL


    def __dealloc__(self):
        if self._c_handler != NULL and self._owns_c_handler:
            del self._c_handler



    ######## Getters ########


    cpdef get_force(self):
        '''get_force() -> Vector3D
        Get the force vector of this wrench

        :rtype: Vector3D

        '''
        return _vector_from_c_value(self._c_handler.get_Force())


    cpdef get_moment(self):
        '''get_moment() -> Vector3D
        Get the moment vector of this wrench

        :rtype: Vector3D

        '''
        return _vector_from_c_value(self._c_handler.get_Moment())


    cpdef get_solid(self):
        '''get_solid() -> Solid
        Get the solid of this wrench

        :rtype: Solid

        '''
        return Solid(<Py_ssize_t>self._c_handler.get_Solid())


    cpdef get_type(self):
        '''get_type() -> str
        Get the type of this wrench

        :rtype: str

        '''
        return (<bytes>self._c_handler.get_Type()).decode()


    cpdef get_point(self):
        '''get_point() -> Point
        Get the point of this wrench

        :rtype: Point

        '''
        return Point(<Py_ssize_t>self._c_handler.get_Point())





    ######## Operations ########


    cpdef unatomize(self):
        return _wrench_from_c_value(self._c_handler.unatomize())


    cpdef at_point(self, point):
        if not isinstance(point, Point):
            raise TypeError('Input argument must be a Point object')
        return _wrench_from_c_value(self._c_handler.at_Point((<Point>point)._c_handler))



    ######## Unary arithmetic operations ########


    def __pos__(self):
        return _wrench_from_c_value(c_deref(self._c_handler))


    def __neg__(self):
        return _wrench_from_c_value(-c_deref(self._c_handler))


    ######## Binary arithmetic operations ########


    def __add__(Wrench3D self, other):
        if not isinstance(other, Wrench3D):
            raise TypeError(f'Unsupported operand type for +: Wrench3D and {type(other).__name__}')
        return _wrench_from_c_value(c_deref(self._c_handler) + c_deref((<Wrench3D>other)._c_handler))



    def __sub__(Wrench3D self, other):
        if not isinstance(other, Wrench3D):
            raise TypeError(f'Unsupported operand type for -: Wrench3D and {type(other).__name__}')
        return _wrench_from_c_value(c_deref(self._c_handler) - c_deref((<Wrench3D>other)._c_handler))



    def __mul__(left_op, right_op):
        if isinstance(left_op, Wrench3D) and isinstance(right_op, Wrench3D):
            # Product between wrenches
            return _expr_from_c(c_deref((<Wrench3D>left_op)._c_handler) * c_deref((<Wrench3D>right_op)._c_handler))

        if not isinstance(left_op, Wrench3D) and not isinstance(right_op, Wrench3D):
            raise TypeError(f'Unsupported operand type for *: {type(left_op).__name__} and {type(right_op).__name__}')

        if isinstance(left_op, Wrench3D):
            right_op = Expr(right_op)
        else:
            left_op, right_op = right_op, Expr(left_op)

        return _wrench_from_c_value(
            (<Expr>right_op)._c_handler *\
            c_deref((<Wrench3D>left_op)._c_handler))



    def __truediv__(left_op, right_op):
        pass



    ######## Properties ########


    @property
    def force(self):
        '''
        Read only property that returns the force vector of this wrench.

        :rtype: Vector3D

        .. note::
            This calls internally to ``get_force``

            .. seealso:: :func:`get_force`

        '''
        return self.get_force()


    @property
    def moment(self):
        '''
        Read only property that returns the moment vector of this wrench.

        :rtype: Vector3D

        .. note::
            This calls internally to ``get_moment``

            .. seealso:: :func:`get_moment`

        '''
        return self.get_moment()


    @property
    def solid(self):
        '''
        Read only property that returns the solid of this wrench.

        :rtype: Solid

        .. note::
            This calls internally to ``get_solid``

            .. seealso:: :func:`get_solid`

        '''
        return self.get_solid()


    @property
    def type(self):
        '''
        Read only property that returns the type of this wrench.

        :rtype: str

        .. note::
            This calls internally to ``get_type``

            .. seealso:: :func:`get_type`

        '''
        return self.get_type()


    @property
    def point(self):
        '''
        Read only property that returns the point of this wrench.

        :rtype: str

        .. note::
            This calls internally to ``get_point``

            .. seealso:: :func:`get_point`

        '''
        return self.get_point()


NamedObject.register(Wrench3D)



######## src/core/pyx/classes/drawing3D.pyx ########



######## Class Drawing3D ########

cdef class Drawing3D(Object):
    '''
    Objects of this class represents drawable elements. They are defined with a
    point, base, vector, scale and color.
    '''

    ######## Attributes ########

    cdef c_Drawing3D* _c_handler


    ######## Constructor ########


    def __cinit__(self, Py_ssize_t handler):
        self._c_handler = <c_Drawing3D*>handler



    ######## Getters ########


    cpdef get_file(self):
        '''get_file() -> str
        Get the file of this drawing object

        :rtype: str

        '''
        return (<bytes>self._c_handler.get_file()).decode()


    cpdef get_type(self):
        '''get_type() -> str
        Get the type of this drawing

        :rtype: str

        '''
        return (<bytes>self._c_handler.get_type()).decode()


    cpdef get_color(self):
        '''get_color() -> List[Expr]
        Get the color components of this drawing

        :rtype: List[Expr]

        '''
        cdef c_lst color = self._c_handler.get_color()
        return [_expr_from_c(color.op(i)) for i in range(0, color.nops())]


    cpdef get_point(self):
        '''get_point() -> Point
        Get the point of this drawing

        :rtype: Point

        '''
        return Point(<Py_ssize_t>self._c_handler.get_Point())


    cpdef get_scale(self):
        '''get_scale() -> numeric
        Get the scale of this drawing

        :rtype: numeric

        '''
        return self._c_handler.get_scale().to_double()


    cpdef get_vector(self):
        '''get_vector() -> Vector3D
        Get the vector of this drawing

        :rtype: Vector3D

        '''
        return _vector_from_c_value(self._c_handler.get_vector())




    ######## Setters ########


    cpdef set_file(self, file):
        '''set_file(file: str)
        Set the file for this drawing

        :type file: str

        '''
        if not isinstance(file, str):
            raise TypeError('Input argument must be a string')
        self._c_handler.set_file(<bytes>file.encode())


    def set_color(self, *args):
        '''set_color(...)
        Set the color of the drawing object.

        You can pass the color components as positional arguments or in a single
        list:

            :Example:

            >>> a = new_drawing('a', get_frame('abs'))
            >>> a.set_color(1, 1, 0, 1)
            >>> a.get_color()
            [1, 1, 0, 1]
            >>> a.set_color([1, 0, 1, 0.5])
            [1, 0, 1, 0.5]

        '''
        if len(args) not in (1, 4):
            raise TypeError('Unexpected number of input arguments')

        try:
            if len(args) != 1:
                values = args
            else:
                values = args[0]
                if not isinstance(values, Iterable):
                    raise TypeError
            values = tuple(map(_parse_numeric_value, values))
            if len(values) != 4:
                raise TypeError
        except TypeError:
            raise TypeError('You must pass a list of four values or four positional arguments')

        cdef c_lst c_color
        for value in values:
            c_color.append(c_ex(c_numeric(<double>value)))

        self._c_handler.set_color(c_color)




    cpdef set_scale(self, scale):
        '''set_scale(scale: numeric)
        Set the scale of this drawing

        :type scale: numeric

        '''
        scale = _parse_numeric_value(scale)
        self._c_handler.set_scale(c_numeric(<double>scale))


    cpdef set_vector(self, vector):
        '''set_vector(vector: Vector3D)
        Set the vector of this drawing

        :type vector: Vector3D

        '''
        if not isinstance(vector, Vector3D):
            raise TypeError('Input argument must be a vector')
        self._c_handler.set_vector(c_deref(<c_Vector3D*>(<Vector3D>vector)._get_c_handler()))



    ######## Properties ########


    @property
    def file(self):
        '''
        Property that can be used to fetch/modify the file of this drawing object.

        :rtype: str

        .. note:: This property used internally the methods ``get_file`` and
            ``set_file``

            .. seealso:: :func:`get_file`

            .. seealso:: :func:`set_file`

        '''
        return self.get_file()

    @file.setter
    def file(self, file):
        self.set_file(file)


    @property
    def point(self):
        '''
        Read only property that fetch the point of this drawing object.

        :rtype: Point

        .. note:: This calls internally to ``get_point``

            .. seealso:: :func:`get_point`

        '''
        return self.get_point()


    @property
    def scale(self):
        '''
        Property that can be used to fetch/modify the scale of this drawing object.

        :rtype: str

        .. note:: This property used internally the methods ``get_scale`` and
            ``set_scale``

            .. seealso:: :func:`get_scale`

            .. seealso:: :func:`set_scale`

        '''
        return self.get_scale()

    @scale.setter
    def scale(self, value):
        self.set_scale(value)


    @property
    def type(self):
        '''
        Read only property that fetch the type of this drawing object.

        :rtype: Point

        .. note:: This calls internally to ``get_type``

            .. seealso:: :func:`get_type`

        '''
        return self.get_type()



    @property
    def vector(self):
        '''
        Read only property that fetch the vector of this drawing object.

        :rtype: Point

        .. note:: This calls internally to ``get_vector``

            .. seealso:: :func:`get_vector`

        '''
        return self.get_vector()

    @vector.setter
    def vector(self, v):
        self.set_vector(v)


    @property
    def color(self):
        '''
        Property that can be used to fetch/modify the color of this drawing object.

        :rtype: str

        .. note:: This property used internally the methods ``get_color`` and
            ``set_color``

            .. seealso:: :func:`get_color`

            .. seealso:: :func:`set_color`

        '''
        return self.get_color()

    @color.setter
    def color(self, values):
        self.set_color(values)




NamedObject.register(Drawing3D)
GeometricObject.register(Drawing3D)



